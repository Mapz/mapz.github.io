<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/link-300x300.gif">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/link-300x300.gif">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/link-300x300.gif">
  <link rel="mask-icon" href="/images/link-300x300.gif" color="#222">
  <link rel="manifest" href="/images/manifest.json">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mapz.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="FIND THE CHILD">
<meta property="og:type" content="website">
<meta property="og:title" content="Mapz&#39;s Blog">
<meta property="og:url" content="http://mapz.github.io/index.html">
<meta property="og:site_name" content="Mapz&#39;s Blog">
<meta property="og:description" content="FIND THE CHILD">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mapz">
<meta property="article:tag" content="游戏开发,UE4">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://mapz.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Mapz's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?69c67c43ced4b46e7ba1656a83e9c872";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mapz's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">可以递归的函数指针</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mapz.github.io/2023/06/29/UE5-2-IrisReplicationSystem%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8EIris%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/link-300x300.gif">
      <meta itemprop="name" content="Mapz">
      <meta itemprop="description" content="FIND THE CHILD">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mapz's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/29/UE5-2-IrisReplicationSystem%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8EIris%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96/" class="post-title-link" itemprop="url">UE5-2-IrisReplicationSystem初探（二）：关于Iris的自定义序列化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-29 16:27:56 / 修改时间：16:29:15" itemprop="dateCreated datePublished" datetime="2023-06-29T16:27:56+08:00">2023-06-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关于-Iris-自定义序列化"><a href="#关于-Iris-自定义序列化" class="headerlink" title="关于 Iris 自定义序列化"></a>关于 Iris 自定义序列化</h1><p>由于 Iris 的同步逻辑发生了变更，所以从前的使用 TStructOpsTypeTraits WithNetSerializer Trait</p>
<p>并定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NetSerialize</span><span class="params">(FArchive&amp; Ar, class UPackageMap* Map, <span class="keyword">bool</span>&amp; bOutSuccess)</span></span>;</span><br></pre></td></tr></table></figure>

<p>的方式也被废弃</p>
<p>我们需要使用新的方式来实现对象的自定义序列化</p>
<p>Iris 使用船新的 FNetSerializer 来进行自定义序列化</p>
<p>如果我们声明了 WithNetSerializer 的 Trait</p>
<p>但是又没有注册 Iris 的 FNetSerializer</p>
<p>会在启动后 Log Warning</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generating descriptor for struct XXX that has custom serialization.</span><br></pre></td></tr></table></figure>

<p>提示你要重新搞个 Serializer，如果没有搞的话</p>
<p>会使用默认的 StructSerializer 来进行处理</p>
<p>默认的 StructSerializer 会遍历所有的 Property 来使用其 Member Serializer 来进行同步</p>
<p>但是由于我们在使用旧版的自定义序列化的时候，通常会有其他的逻辑，不光是同步，所以使用默认的 Iris 同步一般会出现逻辑问题</p>
<p>所以大概率仍需要重新编写 NetSerializer</p>
<p>NetSerializer 主要做的事情大致可以看做下面除去传输过程外的内容</p>
<p>游戏数据-&gt;压缩装箱-&gt;序列化-&gt;[传输过程]-&gt;反序列化-&gt;开箱解压缩-&gt;游戏数据</p>
<p>下面我们以 FHitResultNetSerializer 为例，继续从自定义同步的实现来入手分析 Iris 这部分的工作原理</p>
<p>由于系统中使用了很多编译期逻辑</p>
<p>所以阅读代码需要掌握一些编译期模版元编程的知识</p>
<h1 id="FHitResultNetSerializer-的实现"><a href="#FHitResultNetSerializer-的实现" class="headerlink" title="FHitResultNetSerializer 的实现"></a>FHitResultNetSerializer 的实现</h1><p>HitResultNetSerializer 用于实现 HitResult 的同步</p>
<h2 id="NetSerializer-的定义"><a href="#NetSerializer-的定义" class="headerlink" title="NetSerializer 的定义"></a>NetSerializer 的定义</h2><p>先查看头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright Epic Games, Inc. All Rights Reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Iris/Serialization/NetSerializer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HitResultNetSerializer.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">USTRUCT</span>()</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FHitResultNetSerializerConfig</span> :</span> <span class="keyword">public</span> FNetSerializerConfig</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> UE::Net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UE_NET_DECLARE_SERIALIZER</span>(FHitResultNetSerializer, ENGINE_API);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先是继承 FNetSerializerConfig 实现一个 Config</p>
<p>而后使用宏 UE_NET_DECLARE_SERIALIZER 定义一个 NetSerializer 以及导出</p>
<p>其中宏定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Declare a serializer. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UE_NET_DECLARE_SERIALIZER(SerializerName, Api) struct Api SerializerName ## NetSerializerInfo  \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">    static const UE::Net::FNetSerializer Serializer; \</span></span><br><span class="line"><span class="meta">    static uint32 GetQuantizedTypeSize(); \</span></span><br><span class="line"><span class="meta">    static uint32 GetQuantizedTypeAlignment(); \</span></span><br><span class="line"><span class="meta">    static const FNetSerializerConfig* GetDefaultConfig(); \</span></span><br><span class="line"><span class="meta">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>其中声明了一个 FHitResultNetSerializerNetSerializerInfo 的 struct，其成员为</p>
<ul>
<li>static 的 FNetSerializer，这是通用的 Serializer 的内部数据结构，会根据实现类的信息在编译期设置内容</li>
<li>获取压缩装箱后的类型内存大小的函数</li>
<li>获取压缩装箱后的类型内存对齐的函数</li>
<li>获取同步 Config 的函数</li>
</ul>
<h2 id="NetSerializer-的静态初始化"><a href="#NetSerializer-的静态初始化" class="headerlink" title="NetSerializer 的静态初始化"></a>NetSerializer 的静态初始化</h2><p>那么这些内容是如何初始化的呢？</p>
<p>我们接着查看源文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> UE::Net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FHitResultNetSerializer</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">UE_NET_IMPLEMENT_SERIALIZER</span>(FHitResultNetSerializer);</span><br></pre></td></tr></table></figure>

<p>声明了我们在头文件中使用的那个 FHitResultNetSerializer 实现类</p>
<p>然后使用宏 UE_NET_IMPLEMENT_SERIALIZER 实现其初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implement a serializer using the struct named SerializerName. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UE_NET_IMPLEMENT_SERIALIZER(SerializerName) const UE::Net::FNetSerializer SerializerName ## NetSerializerInfo::Serializer = UE::Net::TNetSerializer<span class="meta-string">&lt;SerializerName&gt;</span>::ConstructNetSerializer(TEXT(#SerializerName)); \</span></span><br><span class="line"><span class="meta">    uint32 SerializerName ## NetSerializerInfo::GetQuantizedTypeSize() &#123; return UE::Net::TNetSerializerBuilder<span class="meta-string">&lt;SerializerName&gt;</span>::GetQuantizedTypeSize(); &#125;; \</span></span><br><span class="line"><span class="meta">    uint32 SerializerName ## NetSerializerInfo::GetQuantizedTypeAlignment() &#123; return UE::Net::TNetSerializerBuilder<span class="meta-string">&lt;SerializerName&gt;</span>::GetQuantizedTypeAlignment(); &#125;; \</span></span><br><span class="line"><span class="meta">    const FNetSerializerConfig* SerializerName ## NetSerializerInfo::GetDefaultConfig() &#123; return UE::Net::TNetSerializerBuilder<span class="meta-string">&lt;SerializerName&gt;</span>::GetDefaultConfig(); &#125;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先是内部 Serializer 的初始化</p>
<p>使用了模版</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UE::Net::TNetSerializer&lt;FHitResultNetSerializer&gt;::<span class="built_in">ConstructNetSerializer</span>(<span class="string">&quot;FHitResultNetSerializer&quot;</span>); </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NetSerializerImpl&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TNetSerializer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> FNetSerializer <span class="title">ConstructNetSerializer</span><span class="params">(<span class="keyword">const</span> TCHAR* Name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TNetSerializerBuilder&lt;NetSerializerImpl&gt; Builder;</span><br><span class="line">        Builder.<span class="built_in">Validate</span>();</span><br><span class="line"></span><br><span class="line">        FNetSerializer Serializer = &#123;&#125;;</span><br><span class="line">        Serializer.Version = Builder.<span class="built_in">GetVersion</span>();</span><br><span class="line">        Serializer.Traits = Builder.<span class="built_in">GetTraits</span>();</span><br><span class="line"></span><br><span class="line">        Serializer.Serialize = Builder.<span class="built_in">GetSerializeFunction</span>();</span><br><span class="line">        Serializer.Deserialize = Builder.<span class="built_in">GetDeserializeFunction</span>();</span><br><span class="line">        Serializer.SerializeDelta = Builder.<span class="built_in">GetSerializeDeltaFunction</span>();</span><br><span class="line">        Serializer.DeserializeDelta = Builder.<span class="built_in">GetDeserializeDeltaFunction</span>();</span><br><span class="line">        Serializer.Quantize = Builder.<span class="built_in">GetQuantizeFunction</span>();</span><br><span class="line">        Serializer.Dequantize = Builder.<span class="built_in">GetDequantizeFunction</span>();</span><br><span class="line">        Serializer.IsEqual = Builder.<span class="built_in">GetIsEqualFunction</span>();</span><br><span class="line">        Serializer.Validate = Builder.<span class="built_in">GetValidateFunction</span>();</span><br><span class="line">        Serializer.CloneDynamicState = Builder.<span class="built_in">GetCloneDynamicStateFunction</span>();</span><br><span class="line">        Serializer.FreeDynamicState = Builder.<span class="built_in">GetFreeDynamicStateFunction</span>();</span><br><span class="line">        Serializer.CollectNetReferences = Builder.<span class="built_in">GetCollectNetReferencesFunction</span>();</span><br><span class="line"></span><br><span class="line">        Serializer.DefaultConfig = Builder.<span class="built_in">GetDefaultConfig</span>();</span><br><span class="line"></span><br><span class="line">        Serializer.QuantizedTypeSize = Builder.<span class="built_in">GetQuantizedTypeSize</span>();</span><br><span class="line">        Serializer.QuantizedTypeAlignment = Builder.<span class="built_in">GetQuantizedTypeAlignment</span>();</span><br><span class="line"></span><br><span class="line">        Serializer.ConfigTypeSize = Builder.<span class="built_in">GetConfigTypeSize</span>();</span><br><span class="line">        Serializer.ConfigTypeAlignment = Builder.<span class="built_in">GetConfigTypeAlignment</span>();</span><br><span class="line"></span><br><span class="line">        Serializer.Name = Name;</span><br><span class="line">        <span class="keyword">return</span> Serializer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此模版类的用处是使用 NetSerializer 的实现类，来静态初始化 NetSerizlierInfo 中的 Serializer 内容</p>
<p>初始化过程都是在编译期执行的</p>
<p>查看 Builder 的模版类，这是静态初始化的具体逻辑内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NetSerializerImpl&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TNetSerializerBuilder</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中使用了大量的编译期逻辑来给不同类型的 Serializer 赋值不同的参数</p>
<p>例如 Version ，各种 Traits 等</p>
<p>如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version check</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="keyword">static</span> ETrueType <span class="title">TestHasVersion</span><span class="params">(<span class="keyword">typename</span> TEnableIf&lt;std::is_same_v&lt;<span class="keyword">decltype</span>(&amp;FVersion::Version), <span class="keyword">decltype</span>(&amp;U::Version)&gt;&gt;::Type*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">static</span> EFalseType <span class="title">TestHasVersion</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="NetSerializer-的内容简析"><a href="#NetSerializer-的内容简析" class="headerlink" title="NetSerializer 的内容简析"></a>NetSerializer 的内容简析</h2><p>我们来看看 FHitResultNetSerializer 的内容</p>
<h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><p>自定义序列化的版本号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint32 Version = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>编译期如果有这个成员，则 Builder 中 TestHasVersion 为 True</p>
<p>则 Builder 的 Etraits 中的 HasVersion 会设置为 True</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ETraits</span> :</span> <span class="keyword">unsigned</span></span><br><span class="line">&#123;</span><br><span class="line">HasVersion = <span class="built_in"><span class="keyword">unsigned</span></span>(<span class="keyword">decltype</span>(TestHasVersion&lt;NetSerializerImpl&gt;(<span class="literal">nullptr</span>))::Value),</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从而 Builder 的 GetVersion 函数可得其值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">void</span>, <span class="keyword">typename</span> U = <span class="keyword">typename</span> TEnableIf&lt;HasVersion, T&gt;::Type, <span class="keyword">bool</span> V = <span class="literal">true</span>&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> uint32 <span class="built_in">GetVersion</span>() &#123; <span class="keyword">return</span> NetSerializerImpl::Version; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">void</span>, <span class="keyword">typename</span> U = <span class="keyword">typename</span> TEnableIf&lt;!HasVersion, T&gt;::Type, <span class="keyword">char</span> V = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> uint32 <span class="built_in">GetVersion</span>() &#123; <span class="keyword">return</span> ~<span class="number">0U</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>然后在静态初始化的时候，设置到类型的 NetSerializerInfo 的 NetSerialzier 中</p>
<p>当前 Version 参数在同步中我没有找到使用的位置</p>
<p>预计是用于同步数据的版本管理</p>
<h3 id="bIsForwardingSerializer"><a href="#bIsForwardingSerializer" class="headerlink" title="bIsForwardingSerializer"></a>bIsForwardingSerializer</h3><p>是否是转发序列化器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> bIsForwardingSerializer = <span class="literal">true</span>; <span class="comment">// Triggers asserts if a function is missing</span></span><br></pre></td></tr></table></figure>

<p>如果有这个成员</p>
<p>在 Builder 中设置后，获取函数为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">void</span>, <span class="keyword">typename</span> U = <span class="keyword">typename</span> TEnableIf&lt;IsForwardingSerializerIsBool, T&gt;::Type, <span class="keyword">bool</span> V = <span class="literal">true</span>&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="built_in">IsForwardingSerializer</span>() &#123; <span class="keyword">return</span> NetSerializerImpl::bIsForwardingSerializer; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">void</span>, <span class="keyword">typename</span> U = <span class="keyword">typename</span> TEnableIf&lt;!IsForwardingSerializerIsBool, T&gt;::Type, <span class="keyword">char</span> V = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="built_in">IsForwardingSerializer</span>() &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>如果设置为 true，则需要在 NetSerialzer 实现中实现下面所有的检查所检查的成员，否则编译会失败</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">void</span>, <span class="keyword">typename</span> U = <span class="keyword">typename</span> TEnableIf&lt;<span class="built_in">IsForwardingSerializer</span>(), T&gt;::Type, <span class="keyword">bool</span> V = <span class="literal">true</span>&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">ValidateForwardingSerializer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(HasSerialize, <span class="string">&quot;Forwarding FNetSerializer must implement Serialize.&quot;</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(HasDeserialize, <span class="string">&quot;Forwarding FNetSerializer must implement Deserialize.&quot;</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(HasSerializeDelta, <span class="string">&quot;Forwarding FNetSerializer must implement SerializeDelta.&quot;</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(HasDeserializeDelta, <span class="string">&quot;Forwarding FNetSerializer must implement DeserializeDelta.&quot;</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(HasQuantize, <span class="string">&quot;Forwarding FNetSerializer must implement Quantize.&quot;</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(HasDequantize, <span class="string">&quot;Forwarding FNetSerializer must implement Dequantize.&quot;</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(HasIsEqual, <span class="string">&quot;Forwarding FNetSerializer must implement IsEqual.&quot;</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(HasValidate, <span class="string">&quot;Forwarding FNetSerializer must implement Validate.&quot;</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(HasCloneDynamicState, <span class="string">&quot;Forwarding FNetSerializer must implement CloneDynamicState.&quot;</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(HasFreeDynamicState, <span class="string">&quot;Forwarding FNetSerializer must implement FreeDynamicState.&quot;</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(HasCollectNetReferences, <span class="string">&quot;Forwarding FNetSerializer must implement CollectNetReferences.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">void</span>, <span class="keyword">typename</span> U = <span class="keyword">typename</span> TEnableIf&lt;!<span class="built_in">IsForwardingSerializer</span>(), T&gt;::Type, <span class="keyword">char</span> V = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">ValidateForwardingSerializer</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bHasCustomNetReference"><a href="#bHasCustomNetReference" class="headerlink" title="bHasCustomNetReference"></a>bHasCustomNetReference</h3><p>是否有自定义的 NetReference，如果有的话，可以自己收集需要同步的 NetReference</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> bHasCustomNetReference = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>如果设置了此参数，会在 Validate 静态检查</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(!<span class="built_in">HasCustomNetReference</span>() || (<span class="built_in">HasCustomNetReference</span>() &amp;&amp; HasCollectNetReferences), <span class="string">&quot;FNetSerializer with bHasCustomNetReference = true must implement CollectNetReferences method.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果序列化器没有实现 CollectNetReferences 函数，则会编译失败</p>
<h3 id="bHasDynamicState"><a href="#bHasDynamicState" class="headerlink" title="bHasDynamicState"></a>bHasDynamicState</h3><p>是否有动态 State<br>State 是序列化器用到的数据 Buffer<br>如果有动态 State 意味着需要手动处理 State 的拷贝和释放</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> bHasDynamicState = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>如果设置了此参数，会在 NetSerializer 中增加 Trait</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Traits |= (<span class="built_in">HasDynamicState</span>() ? ENetSerializerTraits::HasDynamicState : ENetSerializerTraits::None);</span><br></pre></td></tr></table></figure>

<p>并且必须添加 CloneDynamicState 和 FreeDynamicState 成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(!HasDynamicStateIsBool || (HasFreeDynamicState &amp;&amp; HasCloneDynamicState), <span class="string">&quot;FNetSerializer must implement CloneDynamicState and FreeDynamicState when it has dynamic state.&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="定义需要同步的内容数据结构"><a href="#定义需要同步的内容数据结构" class="headerlink" title="定义需要同步的内容数据结构"></a>定义需要同步的内容数据结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Types</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EReplicationFlags</span> :</span> uint32</span><br><span class="line">&#123;</span><br><span class="line">    BlockingHit = <span class="number">1U</span>,</span><br><span class="line">    StartPenetrating = BlockingHit &lt;&lt; <span class="number">1U</span>,</span><br><span class="line">    ImpactPointEqualsLocation = StartPenetrating &lt;&lt; <span class="number">1U</span>,</span><br><span class="line">    ImpactNormalEqualsNormal = ImpactPointEqualsLocation &lt;&lt; <span class="number">1U</span>,</span><br><span class="line">    InvalidItem  = ImpactNormalEqualsNormal &lt;&lt; <span class="number">1U</span>,</span><br><span class="line">    InvalidFaceIndex = InvalidItem &lt;&lt; <span class="number">1U</span>,</span><br><span class="line">    NoPenetrationDepth = InvalidFaceIndex &lt;&lt; <span class="number">1U</span>,</span><br><span class="line">    InvalidElementIndex = NoPenetrationDepth &lt;&lt; <span class="number">1U</span>,</span><br><span class="line">    InvalidMyItem = InvalidElementIndex &lt;&lt; <span class="number">1U</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> uint32 ReplicatedFlagCount = <span class="number">9U</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FQuantizedType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in"><span class="keyword">alignas</span></span>(<span class="number">16</span>) uint8 HitResult[<span class="number">316</span>];</span><br><span class="line">    uint32 ReplicationFlags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> FHitResult SourceType;</span><br><span class="line"><span class="keyword">typedef</span> FQuantizedType QuantizedType;</span><br><span class="line"><span class="keyword">typedef</span> FHitResultNetSerializerConfig ConfigType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> ConfigType DefaultConfig;</span><br></pre></td></tr></table></figure>

<p>Flags 用于标记需要同步的内容<br>而后面的 FQuantizedType 用于存储压缩后的数据<br>其中使用了一个 uint8 数组来存储压缩后的数据，其大小是通过计算原 Struct 所需的最大内存来计算的<br>而后面的 ReplicationFlags 是用于存储标记位的<br>SourceType 是原始数据类型<br>QuantizedType 是装箱后的数据类型<br>ConfigType 是同步配置类型</p>
<h3 id="实现的成员函数"><a href="#实现的成员函数" class="headerlink" title="实现的成员函数"></a>实现的成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Serialize</span><span class="params">(FNetSerializationContext&amp;, <span class="keyword">const</span> FNetSerializeArgs&amp; Args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Deserialize</span><span class="params">(FNetSerializationContext&amp;, <span class="keyword">const</span> FNetDeserializeArgs&amp; Args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SerializeDelta</span><span class="params">(FNetSerializationContext&amp;, <span class="keyword">const</span> FNetSerializeDeltaArgs&amp; Args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeserializeDelta</span><span class="params">(FNetSerializationContext&amp;, <span class="keyword">const</span> FNetDeserializeDeltaArgs&amp; Args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quantize</span><span class="params">(FNetSerializationContext&amp;, <span class="keyword">const</span> FNetQuantizeArgs&amp; Args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dequantize</span><span class="params">(FNetSerializationContext&amp;, <span class="keyword">const</span> FNetDequantizeArgs&amp; Args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsEqual</span><span class="params">(FNetSerializationContext&amp;, <span class="keyword">const</span> FNetIsEqualArgs&amp; Args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Validate</span><span class="params">(FNetSerializationContext&amp;, <span class="keyword">const</span> FNetValidateArgs&amp; Args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CloneDynamicState</span><span class="params">(FNetSerializationContext&amp;, <span class="keyword">const</span> FNetCloneDynamicStateArgs&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FreeDynamicState</span><span class="params">(FNetSerializationContext&amp;, <span class="keyword">const</span> FNetFreeDynamicStateArgs&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CollectNetReferences</span><span class="params">(FNetSerializationContext&amp;, <span class="keyword">const</span> FNetCollectReferencesArgs&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="Serialize"><a href="#Serialize" class="headerlink" title="Serialize"></a>Serialize</h4><p>用于从 Internal Buffer 到 比特流的 序列化数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FHitResultNetSerializer::Serialize</span><span class="params">(FNetSerializationContext&amp; Context, <span class="keyword">const</span> FNetSerializeArgs&amp; Args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注 ：Args.Source 是指向序列化数据的指针</span></span><br><span class="line">    <span class="keyword">const</span> QuantizedType&amp; Value = *<span class="keyword">reinterpret_cast</span>&lt;QuantizedType*&gt;(Args.Source);</span><br><span class="line"></span><br><span class="line">    FNetBitStreamWriter* Writer = Context.<span class="built_in">GetBitStreamWriter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注 ：直接写入标记位</span></span><br><span class="line">    <span class="keyword">const</span> uint32 ReplicationFlags = Value.ReplicationFlags;</span><br><span class="line">    Writer-&gt;<span class="built_in">WriteBits</span>(ReplicationFlags, FHitResultNetSerializer::ReplicatedFlagCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to manually serialize the properties as there are some replicated properties that don&#x27;t need to be replicated depending on the data</span></span><br><span class="line">    <span class="comment">// as is the case with some of the bools that are covered by the ReplicationFlags.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> FReplicationStateDescriptor* Descriptor = StructNetSerializerConfigForHitResult.StateDescriptor.<span class="built_in">GetReference</span>();</span><br><span class="line">    <span class="keyword">const</span> FReplicationStateMemberDescriptor* MemberDescriptors = Descriptor-&gt;MemberDescriptors;</span><br><span class="line">    <span class="keyword">const</span> FReplicationStateMemberSerializerDescriptor* MemberSerializerDescriptors = Descriptor-&gt;MemberSerializerDescriptors;</span><br><span class="line">    <span class="keyword">const</span> FReplicationStateMemberDebugDescriptor* MemberDebugDescriptors = Descriptor-&gt;MemberDebugDescriptors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint32 MemberCount = Descriptor-&gt;MemberCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initalize mask as all dirty  </span></span><br><span class="line">    uint32 MemberMaskStorage = ~<span class="number">0U</span>;</span><br><span class="line">    <span class="comment">// 注 ：获得需要同步的可选 Struct 成员</span></span><br><span class="line">    FNetBitArrayView MemberMask = <span class="built_in">GetMemberChangeMask</span>(&amp;MemberMaskStorage, MemberCount, ReplicationFlags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (uint32 MemberIndex = <span class="number">0</span>; MemberIndex &lt; MemberCount; ++MemberIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!MemberMask.<span class="built_in">GetBit</span>(MemberIndex))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注 ： 序列化需要同步的成员</span></span><br><span class="line">        <span class="keyword">const</span> FReplicationStateMemberDescriptor&amp; MemberDescriptor = MemberDescriptors[MemberIndex];</span><br><span class="line">        <span class="keyword">const</span> FReplicationStateMemberSerializerDescriptor&amp; MemberSerializerDescriptor = MemberSerializerDescriptors[MemberIndex];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UE_NET_TRACE_DYNAMIC_NAME_SCOPE</span>(MemberDebugDescriptors[MemberIndex].DebugName, *Context.<span class="built_in">GetBitStreamWriter</span>(), Context.<span class="built_in">GetTraceCollector</span>(), ENetTraceVerbosity::Verbose);</span><br><span class="line">        <span class="built_in">UE_NET_TRACE_DYNAMIC_NAME_SCOPE</span>(MemberSerializerDescriptor.Serializer-&gt;Name, *Context.<span class="built_in">GetBitStreamWriter</span>(), Context.<span class="built_in">GetTraceCollector</span>(), ENetTraceVerbosity::VeryVerbose);</span><br><span class="line"></span><br><span class="line">        FNetSerializeArgs MemberSerializeArgs;</span><br><span class="line">        MemberSerializeArgs.NetSerializerConfig = MemberSerializerDescriptor.SerializerConfig;</span><br><span class="line">        MemberSerializeArgs.Source = <span class="keyword">reinterpret_cast</span>&lt;NetSerializerValuePointer&gt;(&amp;Value.HitResult) + MemberDescriptor.InternalMemberOffset;</span><br><span class="line">        <span class="comment">// 注 ：序列化成员</span></span><br><span class="line">        MemberSerializerDescriptor.Serializer-&gt;<span class="built_in">Serialize</span>(Context, MemberSerializeArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Deserialize"><a href="#Deserialize" class="headerlink" title="Deserialize"></a>Deserialize</h4><p>用于从头 比特流 反序列化数据 到 Internal Buffer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FHitResultNetSerializer::Deserialize</span><span class="params">(FNetSerializationContext&amp; Context, <span class="keyword">const</span> FNetDeserializeArgs&amp; Args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QuantizedType&amp; Target = *<span class="keyword">reinterpret_cast</span>&lt;QuantizedType*&gt;(Args.Target);</span><br><span class="line"></span><br><span class="line">    FNetBitStreamReader* Reader = Context.<span class="built_in">GetBitStreamReader</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注：先读取标记位</span></span><br><span class="line">    <span class="keyword">const</span> uint32 ReplicationFlags = Reader-&gt;<span class="built_in">ReadBits</span>(FHitResultNetSerializer::ReplicatedFlagCount);</span><br><span class="line">    Target.ReplicationFlags = ReplicationFlags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to manually serialize the properties as there are some replicated properties that don&#x27;t need to be replicated depending on the data</span></span><br><span class="line">    <span class="comment">// as is the case with some of the bools that are covered by the ReplicationFlags.</span></span><br><span class="line">    <span class="keyword">const</span> FReplicationStateDescriptor* Descriptor = StructNetSerializerConfigForHitResult.StateDescriptor.<span class="built_in">GetReference</span>();</span><br><span class="line">    <span class="keyword">const</span> FReplicationStateMemberDescriptor* MemberDescriptors = Descriptor-&gt;MemberDescriptors;</span><br><span class="line">    <span class="keyword">const</span> FReplicationStateMemberSerializerDescriptor* MemberSerializerDescriptors = Descriptor-&gt;MemberSerializerDescriptors;</span><br><span class="line">    <span class="keyword">const</span> FReplicationStateMemberDebugDescriptor* MemberDebugDescriptors = Descriptor-&gt;MemberDebugDescriptors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint32 MemberCount = Descriptor-&gt;MemberCount;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initalize mask as all dirty  </span></span><br><span class="line">    uint32 MemberMaskStorage = ~<span class="number">0U</span>;</span><br><span class="line">    <span class="comment">// 获取要反序列化的内容</span></span><br><span class="line">    FNetBitArrayView MemberMask = <span class="built_in">GetMemberChangeMask</span>(&amp;MemberMaskStorage, MemberCount, ReplicationFlags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (uint32 MemberIndex = <span class="number">0</span>; MemberIndex &lt; MemberCount; ++MemberIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!MemberMask.<span class="built_in">GetBit</span>(MemberIndex))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> FReplicationStateMemberDescriptor&amp; MemberDescriptor = MemberDescriptors[MemberIndex];</span><br><span class="line">        <span class="keyword">const</span> FReplicationStateMemberSerializerDescriptor&amp; MemberSerializerDescriptor = MemberSerializerDescriptors[MemberIndex];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UE_NET_TRACE_DYNAMIC_NAME_SCOPE</span>(MemberDebugDescriptors[MemberIndex].DebugName, *Context.<span class="built_in">GetBitStreamReader</span>(), Context.<span class="built_in">GetTraceCollector</span>(), ENetTraceVerbosity::Verbose);</span><br><span class="line">        <span class="built_in">UE_NET_TRACE_DYNAMIC_NAME_SCOPE</span>(MemberSerializerDescriptor.Serializer-&gt;Name, *Context.<span class="built_in">GetBitStreamReader</span>(), Context.<span class="built_in">GetTraceCollector</span>(), ENetTraceVerbosity::VeryVerbose);</span><br><span class="line"></span><br><span class="line">        FNetDeserializeArgs MemberDeserializeArgs;</span><br><span class="line">        MemberDeserializeArgs.NetSerializerConfig = MemberSerializerDescriptor.SerializerConfig;</span><br><span class="line">        MemberDeserializeArgs.Target = <span class="keyword">reinterpret_cast</span>&lt;NetSerializerValuePointer&gt;(&amp;Target.HitResult) + MemberDescriptor.InternalMemberOffset;</span><br><span class="line">        MemberSerializerDescriptor.Serializer-&gt;<span class="built_in">Deserialize</span>(Context, MemberDeserializeArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SerializeDelta-和-DeserializeDelta"><a href="#SerializeDelta-和-DeserializeDelta" class="headerlink" title="SerializeDelta 和 DeserializeDelta"></a>SerializeDelta 和 DeserializeDelta</h4><p>用于序列化和反序列化 Delta 数据</p>
<p>可以在前面的 State 的基础上，做增量序列化</p>
<p>这样可以只同步变化内容，进一步减少同步所需数据量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For now just use normal serialization for delta as this struct typically is a one off.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FHitResultNetSerializer::SerializeDelta</span><span class="params">(FNetSerializationContext&amp; Context, <span class="keyword">const</span> FNetSerializeDeltaArgs&amp; Args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NetSerializeDeltaDefault&lt;Serialize&gt;(Context, Args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FHitResultNetSerializer::DeserializeDelta</span><span class="params">(FNetSerializationContext&amp; Context, <span class="keyword">const</span> FNetDeserializeDeltaArgs&amp; Args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NetDeserializeDeltaDefault&lt;Deserialize&gt;(Context, Args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读模版函数 NetSerializeDeltaDefault 和 NetDeserializeDeltaDefault</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;NetSerializeFunction Serialize&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">NetSerializeDeltaDefault</span><span class="params">(FNetSerializationContext&amp; Context, <span class="keyword">const</span> FNetSerializeDeltaArgs&amp; Args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Serialize</span>(Context, Args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;NetDeserializeFunction Deserialize&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">NetDeserializeDeltaDefault</span><span class="params">(FNetSerializationContext&amp; Context, <span class="keyword">const</span> FNetDeserializeDeltaArgs&amp; Args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Deserialize</span>(Context, Args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知本 Serializer 中直接使用了 Serialize 和 Deserialize 来处理 Delta Serialize 的内容，并没有做增量优化</p>
<h4 id="Quantize-和-Dequantize"><a href="#Quantize-和-Dequantize" class="headerlink" title="Quantize 和 Dequantize"></a>Quantize 和 Dequantize</h4><p>用于从 External Buffer 到 Internal Buffer 的 “量子化” 和 “逆量子化”<br>可以理解为装箱和开箱，装箱指把原始数据处理成可用来同步的数据，开箱指把同步数据处理成原始数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">在 HitResult 中，做了一次全量的量子化和逆量子化，并处理了 Flag 的更新</span><br><span class="line">由于 Quantize 是在 Serialize 之前调用的，所以在 Serialize 中可以直接使用量子化后的数据</span><br><span class="line"></span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FHitResultNetSerializer::Quantize</span><span class="params">(FNetSerializationContext&amp; Context, <span class="keyword">const</span> FNetQuantizeArgs&amp; Args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> SourceType&amp; SourceValue = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> SourceType*&gt;(Args.Source);</span><br><span class="line">    QuantizedType&amp; TargetValue = *<span class="keyword">reinterpret_cast</span>&lt;QuantizedType*&gt;(Args.Target);</span><br><span class="line">    </span><br><span class="line">    uint32 ReplicationFlags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update flags based on SourceValue</span></span><br><span class="line">    <span class="comment">// 注：根据 SourceValue 的内容更新标记位</span></span><br><span class="line">    ReplicationFlags |= SourceValue.ImpactPoint == SourceValue.Location ? EReplicationFlags::ImpactPointEqualsLocation : <span class="number">0U</span>;</span><br><span class="line">    ReplicationFlags |= SourceValue.ImpactNormal == SourceValue.Normal ? EReplicationFlags::ImpactNormalEqualsNormal : <span class="number">0U</span>;</span><br><span class="line">    ReplicationFlags |= SourceValue.MyItem == INDEX_NONE ? EReplicationFlags::InvalidMyItem : <span class="number">0U</span>;</span><br><span class="line">    ReplicationFlags |= SourceValue.Item == INDEX_NONE ? EReplicationFlags::InvalidItem : <span class="number">0U</span>;</span><br><span class="line">    ReplicationFlags |= SourceValue.FaceIndex == INDEX_NONE ? EReplicationFlags::InvalidFaceIndex : <span class="number">0U</span>;</span><br><span class="line">    ReplicationFlags |= (SourceValue.PenetrationDepth == <span class="number">0.0f</span>) ? EReplicationFlags::NoPenetrationDepth : <span class="number">0U</span>;</span><br><span class="line">    ReplicationFlags |= SourceValue.ElementIndex == INDEX_NONE ? EReplicationFlags::InvalidElementIndex : <span class="number">0U</span>;</span><br><span class="line">    ReplicationFlags |= SourceValue.bBlockingHit ? EReplicationFlags::BlockingHit : <span class="number">0U</span>;</span><br><span class="line">    ReplicationFlags |= SourceValue.bStartPenetrating ? EReplicationFlags::StartPenetrating : <span class="number">0U</span>;</span><br><span class="line">    </span><br><span class="line">    TargetValue.ReplicationFlags = ReplicationFlags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We do a full quantize even though we wont necessarily serialize them.</span></span><br><span class="line">    <span class="comment">// 注：做了一次 Full Quantize</span></span><br><span class="line">    FNetQuantizeArgs HitResultQuantizeArgs = &#123;&#125;;</span><br><span class="line">    HitResultQuantizeArgs.NetSerializerConfig = &amp;StructNetSerializerConfigForHitResult;</span><br><span class="line">    HitResultQuantizeArgs.Source = Args.Source;</span><br><span class="line">    HitResultQuantizeArgs.Target = <span class="built_in">NetSerializerValuePointer</span>(&amp;TargetValue.HitResult);</span><br><span class="line">    StructNetSerializer-&gt;<span class="built_in">Quantize</span>(Context, HitResultQuantizeArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FHitResultNetSerializer::Dequantize</span><span class="params">(FNetSerializationContext&amp; Context, <span class="keyword">const</span> FNetDequantizeArgs&amp; Args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> QuantizedType&amp; SourceValue = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> QuantizedType*&gt;(Args.Source);</span><br><span class="line">    SourceType&amp; TargetValue = *<span class="keyword">reinterpret_cast</span>&lt;SourceType*&gt;(Args.Target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint32 ReplicatonFlags = SourceValue.ReplicationFlags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Dequantize all and fixup afterwards</span></span><br><span class="line">    FNetDequantizeArgs HitResultQuantizeArgs = &#123;&#125;;</span><br><span class="line">    HitResultQuantizeArgs.NetSerializerConfig = &amp;StructNetSerializerConfigForHitResult;</span><br><span class="line">    HitResultQuantizeArgs.Source = <span class="built_in">NetSerializerValuePointer</span>(&amp;SourceValue.HitResult);</span><br><span class="line">    HitResultQuantizeArgs.Target = Args.Target;</span><br><span class="line">    StructNetSerializer-&gt;<span class="built_in">Dequantize</span>(Context, HitResultQuantizeArgs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ReplicatonFlags &amp; EReplicationFlags::ImpactPointEqualsLocation)</span><br><span class="line">    &#123;</span><br><span class="line">        TargetValue.ImpactPoint = TargetValue.Location;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ReplicatonFlags &amp; EReplicationFlags::ImpactNormalEqualsNormal)</span><br><span class="line">    &#123;</span><br><span class="line">        TargetValue.ImpactNormal = TargetValue.Normal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ReplicatonFlags &amp; EReplicationFlags::InvalidMyItem)</span><br><span class="line">    &#123;</span><br><span class="line">        TargetValue.MyItem = INDEX_NONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ReplicatonFlags &amp; EReplicationFlags::InvalidItem)</span><br><span class="line">    &#123;</span><br><span class="line">        TargetValue.Item = INDEX_NONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ReplicatonFlags &amp; EReplicationFlags::InvalidFaceIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        TargetValue.FaceIndex = INDEX_NONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ReplicatonFlags &amp; EReplicationFlags::NoPenetrationDepth)</span><br><span class="line">    &#123;</span><br><span class="line">        TargetValue.PenetrationDepth = <span class="number">0.f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ReplicatonFlags &amp; EReplicationFlags::InvalidElementIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        TargetValue.ElementIndex = INDEX_NONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate distance</span></span><br><span class="line">    TargetValue.Distance = (TargetValue.ImpactPoint - TargetValue.TraceStart).<span class="built_in">Size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the bBlockingHit and bStartPenetrating from the flags</span></span><br><span class="line">    TargetValue.bBlockingHit = (ReplicatonFlags &amp; EReplicationFlags::BlockingHit) != <span class="number">0U</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    TargetValue.bStartPenetrating = (ReplicatonFlags &amp; EReplicationFlags::StartPenetrating) != <span class="number">0U</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IsEqual"><a href="#IsEqual" class="headerlink" title="IsEqual"></a>IsEqual</h4><p>用于对比两个 Internal Buffer 的内容是否相同，用于确认对象是否 Dirty 从而确认是否需要同步<br>这里分别对比了 State 是 装箱 后的数据的情况和 State 是原始数据的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FHitResultNetSerializer::IsEqual</span><span class="params">(FNetSerializationContext&amp; Context, <span class="keyword">const</span> FNetIsEqualArgs&amp; Args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Args.bStateIsQuantized)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> QuantizedType&amp; Value0 = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> QuantizedType*&gt;(Args.Source0);</span><br><span class="line">        <span class="keyword">const</span> QuantizedType&amp; Value1 = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> QuantizedType*&gt;(Args.Source1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Value0.ReplicationFlags != Value1.ReplicationFlags)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do a per member compare of relevant members</span></span><br><span class="line">        <span class="keyword">const</span> FReplicationStateDescriptor* Descriptor = StructNetSerializerConfigForHitResult.StateDescriptor.<span class="built_in">GetReference</span>();</span><br><span class="line">        <span class="keyword">const</span> FReplicationStateMemberDescriptor* MemberDescriptors = Descriptor-&gt;MemberDescriptors;</span><br><span class="line">        <span class="keyword">const</span> FReplicationStateMemberSerializerDescriptor* MemberSerializerDescriptors = Descriptor-&gt;MemberSerializerDescriptors;</span><br><span class="line">        <span class="keyword">const</span> FReplicationStateMemberDebugDescriptor* MemberDebugDescriptors = Descriptor-&gt;MemberDebugDescriptors;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> uint32 MemberCount = Descriptor-&gt;MemberCount;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Initalize mask as all dirty  </span></span><br><span class="line">        uint32 MemberMaskStorage = ~<span class="number">0U</span>;</span><br><span class="line">        FNetBitArrayView MemberMask = <span class="built_in">GetMemberChangeMask</span>(&amp;MemberMaskStorage, MemberCount, Value0.ReplicationFlags);</span><br><span class="line"></span><br><span class="line">        FNetIsEqualArgs MemberArgs;</span><br><span class="line">        MemberArgs.Version = <span class="number">0</span>;</span><br><span class="line">        MemberArgs.bStateIsQuantized = Args.bStateIsQuantized;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (uint32 MemberIt = <span class="number">0</span>; MemberIt &lt; MemberCount; ++MemberIt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!MemberMask.<span class="built_in">GetBit</span>(MemberIt))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> FReplicationStateMemberDescriptor&amp; MemberDescriptor = MemberDescriptors[MemberIt];</span><br><span class="line">            <span class="keyword">const</span> FReplicationStateMemberSerializerDescriptor&amp; MemberSerializerDescriptor = MemberSerializerDescriptors[MemberIt];</span><br><span class="line">            <span class="keyword">const</span> FNetSerializer* Serializer = MemberSerializerDescriptor.Serializer;</span><br><span class="line"></span><br><span class="line">            MemberArgs.NetSerializerConfig = MemberSerializerDescriptor.SerializerConfig;</span><br><span class="line">            <span class="keyword">const</span> uint32 MemberOffset = MemberDescriptor.InternalMemberOffset;</span><br><span class="line">            MemberArgs.Source0 = <span class="keyword">reinterpret_cast</span>&lt;NetSerializerValuePointer&gt;(&amp;Value0.HitResult) + MemberDescriptor.InternalMemberOffset;</span><br><span class="line">            MemberArgs.Source1 = <span class="keyword">reinterpret_cast</span>&lt;NetSerializerValuePointer&gt;(&amp;Value1.HitResult) + MemberDescriptor.InternalMemberOffset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!Serializer-&gt;<span class="built_in">IsEqual</span>(Context, MemberArgs))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        FNetIsEqualArgs HitResultEqualArgs = Args;</span><br><span class="line">        HitResultEqualArgs.NetSerializerConfig = &amp;StructNetSerializerConfigForHitResult;</span><br><span class="line">        HitResultEqualArgs.Source0 = <span class="built_in">NetSerializerValuePointer</span>(Args.Source0);</span><br><span class="line">        HitResultEqualArgs.Source1 = <span class="built_in">NetSerializerValuePointer</span>(Args.Source1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!StructNetSerializer-&gt;<span class="built_in">IsEqual</span>(Context, HitResultEqualArgs))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a>Validate</h4><p>校验正确性，我暂时没有找到使用的地方</p>
<h4 id="FreeDynamicState-和-CloneDynamicState"><a href="#FreeDynamicState-和-CloneDynamicState" class="headerlink" title="FreeDynamicState 和 CloneDynamicState"></a>FreeDynamicState 和 CloneDynamicState</h4><p>用于自定义动态的 State 数据的拷贝和释放</p>
<p>释放一般调用于 NetBlob 的释放的时候</p>
<p>例如发送收到临时的传输，比如 Unreliable 信息的传输，就会在发送或者收到后立即释放其 State</p>
<p>又例如在 Array 中，如果有元素移除，也会释放其 State</p>
<p>而克隆会在需要拷贝 State 的时候调用</p>
<p>例如发送信息后，会把当前的 State 拷贝一份作为基准，用于后续的 Delta 比较</p>
<p>具体实现内容略</p>
<h4 id="CollectNetReferences"><a href="#CollectNetReferences" class="headerlink" title="CollectNetReferences"></a>CollectNetReferences</h4><p>用于收集需要同步的内容</p>
<p>例如发送和接收 RPC 的参数</p>
<p>发送数据的时候</p>
<p>HitResult 内此函数只做了转发，所以内容略去</p>
<h3 id="注册同步类型到自定义-Serializer"><a href="#注册同步类型到自定义-Serializer" class="headerlink" title="注册同步类型到自定义 Serializer"></a>注册同步类型到自定义 Serializer</h3><p>我们可以看到在 Serializer 的实现中，声明了一个内部类</p>
<p>并指定了一个静态成员用于注册类型</p>
<p>这个内部类用于处理注册 Serializer 到系统中，以及初始化相关 Serializer 的相关参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FHitResultNetSerializer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 用于注册的内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FNetSerializerRegistryDelegates</span> <span class="keyword">final</span> :</span> <span class="keyword">private</span> UE::Net::FNetSerializerRegistryDelegates</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">FNetSerializerRegistryDelegates</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 委托的挂载会在和卸载会在父类的构造函数和析构函数中自动执行，这里只需要重写两个虚函数即可</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPreFreezeNetSerializerRegistry</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPostFreezeNetSerializerRegistry</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 静态成员</span></span><br><span class="line">    <span class="keyword">static</span> FHitResultNetSerializer::FNetSerializerRegistryDelegates NetSerializerRegistryDelegates;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 创建内部类的静态成员实例</span></span><br><span class="line">FHitResultNetSerializer::FNetSerializerRegistryDelegates FHitResultNetSerializer::NetSerializerRegistryDelegates;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体的注册过程如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个名称，这个名称和 Struct 的名称一致</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> FName <span class="title">PropertyNetSerializerRegistry_NAME_HitResult</span><span class="params">(<span class="string">&quot;HitResult&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个宏，会实现一个 FPropertyNetSerializerInfo ，其中包含其类型的序列化名称和其 Serializer</span></span><br><span class="line"><span class="built_in">UE_NET_IMPLEMENT_NAMED_STRUCT_NETSERIALIZER_INFO</span>(PropertyNetSerializerRegistry_NAME_HitResult, FHitResultNetSerializer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 FNetSerializerRegistryDelegates 的析构函数中，我们注销 NetSerializer Info</span></span><br><span class="line">FHitResultNetSerializer::FNetSerializerRegistryDelegates::~<span class="built_in">FNetSerializerRegistryDelegates</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这个宏用于注销类型的序列化器，必须依托 UE_NET_IMPLEMENT_NAMED_STRUCT_NETSERIALIZER_INFO</span></span><br><span class="line">    <span class="built_in">UE_NET_UNREGISTER_NETSERIALIZER_INFO</span>(PropertyNetSerializerRegistry_NAME_HitResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 OnPreFreezeNetSerializerRegistry 中，我们注册 NetSerializer Info</span></span><br><span class="line"><span class="keyword">void</span> FHitResultNetSerializer::FNetSerializerRegistryDelegates::<span class="built_in">OnPreFreezeNetSerializerRegistry</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这个宏用于注册类型的序列化器，必须依托 UE_NET_IMPLEMENT_NAMED_STRUCT_NETSERIALIZER_INFO</span></span><br><span class="line">    <span class="built_in">UE_NET_REGISTER_NETSERIALIZER_INFO</span>(PropertyNetSerializerRegistry_NAME_HitResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 OnPostFreezeNetSerializerRegistry 中，我们可以配置序列化器</span></span><br><span class="line"><span class="comment">// 并初始化一些需要使用的内容</span></span><br><span class="line"><span class="comment">// 通常是写自己的 StateDescriptor</span></span><br><span class="line"><span class="comment">// Desriptor 属性包括</span></span><br><span class="line"><span class="comment">// 是否包括 Super Class 的 Descriptor</span></span><br><span class="line"><span class="comment">// GetLifeTimeProperties 的属性 (class 适用)</span></span><br><span class="line"><span class="comment">// 是否启用 FastArraySerializer </span></span><br><span class="line"><span class="comment">// 等</span></span><br><span class="line"><span class="keyword">void</span> FHitResultNetSerializer::FNetSerializerRegistryDelegates::<span class="built_in">OnPostFreezeNetSerializerRegistry</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Setup serializer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// In this case we want to build a descriptor based on the struct members rather than the serializer we try to register</span></span><br><span class="line">        FReplicationStateDescriptorBuilder::FParameters Params;</span><br><span class="line">        Params.SkipCheckForCustomNetSerializerForStruct = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> UStruct* HitResultStruct = FHitResult::<span class="built_in">StaticStruct</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Had do comment this out as the size differs between editor and non-editor builds.</span></span><br><span class="line">        <span class="comment">//if (HitResultStruct-&gt;GetStructureSize() != 240 || HitResultStruct-&gt;GetMinAlignment() != 8)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//  LowLevelFatalError(TEXT(&quot;%s Size: %d Alignment: %d&quot;), TEXT(&quot;FHitResult layout has changed. Need to update FHitResultNetSerializer.&quot;), HitResultStruct-&gt;GetStructureSize(), HitResultStruct-&gt;GetMinAlignment());</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 StateDescriptor</span></span><br><span class="line">        StructNetSerializerConfigForHitResult.StateDescriptor = FReplicationStateDescriptorBuilder::<span class="built_in">CreateDescriptorForStruct</span>(HitResultStruct, Params);</span><br><span class="line">        <span class="keyword">const</span> FReplicationStateDescriptor* Descriptor = StructNetSerializerConfigForHitResult.StateDescriptor.<span class="built_in">GetReference</span>();</span><br><span class="line">        <span class="built_in">check</span>(Descriptor != <span class="literal">nullptr</span>);</span><br><span class="line">        HitResultStateTraits = Descriptor-&gt;Traits;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于检查 Serializer 是否适配当前版本的 Struct，这里粗暴的使用了 MemberCount</span></span><br><span class="line">        <span class="keyword">if</span> (Descriptor-&gt;MemberCount &gt; <span class="number">32U</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LowLevelFatalError</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%s Has more than 32 replicated members.&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;FHitResult has changed. Need to update FHitResultNetSerializer.&quot;</span>), Descriptor-&gt;MemberCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Build property -&gt; Member index lookup table</span></span><br><span class="line">        FName PropertyNames[EPropertyName::PropertyName_ConditionallyReplicatedPropertyCount];</span><br><span class="line"></span><br><span class="line">        PropertyNames[PropertyName_FaceIndex] = <span class="built_in">FName</span>(<span class="string">&quot;FaceIndex&quot;</span>);</span><br><span class="line">        PropertyNames[PropertyName_Distance] =  <span class="built_in">FName</span>(<span class="string">&quot;Distance&quot;</span>);</span><br><span class="line">        PropertyNames[PropertyName_ImpactPoint] = <span class="built_in">FName</span>(<span class="string">&quot;ImpactPoint&quot;</span>);</span><br><span class="line">        PropertyNames[PropertyName_ImpactNormal] = <span class="built_in">FName</span>(<span class="string">&quot;ImpactNormal&quot;</span>);</span><br><span class="line">        PropertyNames[PropertyName_PenetrationDepth] = <span class="built_in">FName</span>(<span class="string">&quot;PenetrationDepth&quot;</span>);</span><br><span class="line">        PropertyNames[PropertyName_MyItem] = <span class="built_in">FName</span>(<span class="string">&quot;MyItem&quot;</span>);</span><br><span class="line">        PropertyNames[PropertyName_Item] = <span class="built_in">FName</span>(<span class="string">&quot;Item&quot;</span>);</span><br><span class="line">        PropertyNames[PropertyName_ElementIndex] = <span class="built_in">FName</span>(<span class="string">&quot;ElementIndex&quot;</span>);</span><br><span class="line">        PropertyNames[PropertyName_bBlockingHit] = <span class="built_in">FName</span>(<span class="string">&quot;bBlockingHit&quot;</span>);</span><br><span class="line">        PropertyNames[PropertyName_bStartPenetrating] = <span class="built_in">FName</span>(<span class="string">&quot;bStartPenetrating&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uint32 FoundPropertyMask = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find all replicated properties of interest.</span></span><br><span class="line">        <span class="comment">// 这里遍历所有同步成员，制作了一个 PropertyToMemberIndex，可用于标记 MemberMark ，标识哪一个成员发生了变化，并只同步变化的内容</span></span><br><span class="line">        <span class="comment">// 使用见 GetMemberChangeMask 和 Serializer 函数</span></span><br><span class="line">        <span class="keyword">const</span> FProperty*<span class="keyword">const</span>*MemberProperties = Descriptor-&gt;MemberProperties;</span><br><span class="line">        <span class="keyword">for</span> (uint32 PropertyIndex = <span class="number">0</span>; PropertyIndex != EPropertyName::PropertyName_ConditionallyReplicatedPropertyCount; ++PropertyIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> FProperty*<span class="keyword">const</span>&amp; MemberProperty : <span class="built_in">MakeArrayView</span>(MemberProperties, Descriptor-&gt;MemberCount))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">const</span> SIZE_T MemberIndex = &amp;MemberProperty - MemberProperties;</span><br><span class="line">                <span class="keyword">if</span> (MemberProperty-&gt;<span class="built_in">GetFName</span>() == PropertyNames[PropertyIndex])</span><br><span class="line">                &#123;</span><br><span class="line">                    FoundPropertyMask |= <span class="number">1U</span> &lt;&lt; PropertyIndex;</span><br><span class="line"></span><br><span class="line">                    FHitResultNetSerializer::PropertyToMemberIndex[PropertyIndex] = MemberIndex;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FoundPropertyMask != (<span class="number">1U</span> &lt;&lt;  EPropertyName::PropertyName_ConditionallyReplicatedPropertyCount) - <span class="number">1U</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LowLevelFatalError</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%s&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;Couldn&#x27;t find expected replicated members in FHitResult.&quot;</span>)); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验空间大小是否正确</span></span><br><span class="line">        <span class="comment">// Validate our assumptions regarding quantized state size and alignment.</span></span><br><span class="line">        <span class="keyword">constexpr</span> SIZE_T OffsetOfHitResult = <span class="built_in">offsetof</span>(FQuantizedType, HitResult);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in"><span class="keyword">sizeof</span></span>(FQuantizedType::HitResult) &lt; Descriptor-&gt;InternalSize) || (((OffsetOfHitResult/Descriptor-&gt;InternalAlignment)*Descriptor-&gt;InternalAlignment) != OffsetOfHitResult))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LowLevelFatalError</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;FQuantizedType::HitResult has size %u but requires size %u and alignment %u.&quot;</span>), <span class="built_in">uint32</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(FQuantizedType::HitResult)), <span class="built_in">uint32</span>(Descriptor-&gt;InternalSize), <span class="built_in">uint32</span>(Descriptor-&gt;InternalAlignment));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify traits</span></span><br><span class="line">    <span class="comment">// 校验生成的 Traits 是否正确</span></span><br><span class="line">    <span class="built_in">ValidateForwardingNetSerializerTraits</span>(&amp;<span class="built_in">UE_NET_GET_SERIALIZER</span>(FHitResultNetSerializer), HitResultStateTraits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们的 HitResult 的自定义同步编写和注册完成了</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在新的架构下，编写自定义序列化，功能更加齐全，也可以全流程掌控和优化</p>
<p>但是当前版本中</p>
<p>编写自定义序列化的工作，变得异常复杂，成本陡增，甚至需要专人去做维护</p>
<p>有时候我们只是希望省去几个字节的流量，却要编写一大堆公式化的内容</p>
<p>并且由于结构体和 Serializer 内容的逻辑分开了</p>
<p>维护也产生了困难</p>
<p>例如结构体发生改变后，Serializer 并没有更新，有可能在没有任何提示的情况下，出现未知的问题</p>
<p>希望在 Iris 继续迭代后</p>
<p>能在用户侧简化 NetSerializer 的编写或者定制</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mapz.github.io/2023/06/21/UE5%EF%BC%9AIrisReplicationSystem%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%88%90%E5%8A%9F%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8Iris%E5%90%8C%E6%AD%A5%E4%BB%A5%E5%8F%8A%E5%8F%82%E8%80%83%E9%85%8D%E7%BD%AE%E7%AE%80%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/link-300x300.gif">
      <meta itemprop="name" content="Mapz">
      <meta itemprop="description" content="FIND THE CHILD">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mapz's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/21/UE5%EF%BC%9AIrisReplicationSystem%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%88%90%E5%8A%9F%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8Iris%E5%90%8C%E6%AD%A5%E4%BB%A5%E5%8F%8A%E5%8F%82%E8%80%83%E9%85%8D%E7%BD%AE%E7%AE%80%E6%9E%90/" class="post-title-link" itemprop="url">UE5：IrisReplicationSystem初探（一）：成功在项目启动Iris同步以及参考配置简析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-21 17:40:44 / 修改时间：17:43:01" itemprop="dateCreated datePublished" datetime="2023-06-21T17:40:44+08:00">2023-06-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>Iris 从进入 Roadmap 到现在已经过了一段时间了，但是网上相关内容不多，正值 5.2 版本正式发布， Lyra 范例项目也更新了可使用 Iris 的版本</p>
<p>这里根据 Lyra 的配置方式，在作者的项目中启用成功</p>
<p>下面我会将成功启动同步的配置方式列出，再逐一的探索解释每个配置的用途</p>
<p>希望对大家有所帮助</p>
<p>以下内容全部基于 UE 5.2.0 版本</p>
<p>阅读时需有一些 UE 网络同步相关的基础知识</p>
<h1 id="启用-Iris-Replication"><a href="#启用-Iris-Replication" class="headerlink" title="启用 Iris Replication"></a>启用 Iris Replication</h1><h3 id="编译时"><a href="#编译时" class="headerlink" title="编译时"></a>编译时</h3><p>uproject 文件中，添加 plugin</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;Name&quot;: &quot;Iris&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;Enabled&quot;: true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Build.cs 文件中，添加调用</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SetupIrisSupport</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>DefaultEngine.ini</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[/Script/Engine.Engine]</span></span><br><span class="line"></span><br><span class="line">!<span class="attr">IrisNetDriverConfigs</span>=ClearArray</span><br><span class="line"></span><br><span class="line">+<span class="attr">IrisNetDriverConfigs</span>=(NetDriverDefinition=<span class="string">&quot;你的NetDriver名&quot;</span>,NetDriverName=<span class="string">&quot;你的NetDriver名&quot;</span>,NetDriverWildcardName=<span class="string">&quot;你的NetDriver名*&quot;</span>,bEnableIris=<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[/Script/Engine.NetDriver]</span></span><br><span class="line"></span><br><span class="line">+<span class="attr">ChannelDefinitions</span>=(ChannelName=DataStream, ClassName=/Script/Engine.DataStreamChannel, StaticChannelIndex=<span class="number">2</span>, bTickOnCreate=<span class="literal">true</span>, bServerOpen=<span class="literal">true</span>, bClientOpen=<span class="literal">true</span>, bInitialServer=<span class="literal">true</span>, bInitialClient=<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[/Script/IrisCore.PartialNetObjectAttachmentHandlerConfig]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">MaxPartCount</span>=<span class="number">4096</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[/Script/IrisCore.NetBlobHandlerDefinitions]</span></span><br><span class="line"></span><br><span class="line">+<span class="attr">NetBlobHandlerDefinitions</span>=(ClassName=NetRPCHandler)</span><br><span class="line"></span><br><span class="line">+<span class="attr">NetBlobHandlerDefinitions</span>=(ClassName=PartialNetObjectAttachmentHandler )</span><br><span class="line"></span><br><span class="line">+<span class="attr">NetBlobHandlerDefinitions</span>=(ClassName=NetObjectBlobHandler)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[/Script/IrisCore.DataStreamDefinitions]</span></span><br><span class="line"></span><br><span class="line">+<span class="attr">DataStreamDefinitions</span>=(DataStreamName=NetToken, ClassName=/Script/IrisCore.NetTokenDataStream, DefaultSendStatus=EDataStreamSendStatus::Send, bAutoCreate=<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">+<span class="attr">DataStreamDefinitions</span>=(DataStreamName=Replication, ClassName=/Script/IrisCore.ReplicationDataStream, DefaultSendStatus=EDataStreamSendStatus::Send, bAutoCreate=<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[/Script/IrisCore.NetObjectPrioritizerDefinitions]</span></span><br><span class="line"></span><br><span class="line">+<span class="attr">NetObjectPrioritizerDefinitions</span>=(PrioritizerName=Default, ClassName=/Script/IrisCore.SphereNetObjectPrioritizer, ConfigClassName=/Script/IrisCore.SphereNetObjectPrioritizerConfig)</span><br><span class="line"></span><br><span class="line">+<span class="attr">NetObjectPrioritizerDefinitions</span>=(PrioritizerName=PlayerState, ClassName=/Script/IrisCore.NetObjectCountLimiter, ConfigClassName=/Script/Engine.PlayerStateCountLimiterConfig)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[/Script/IrisCore.NetObjectFilterDefinitions]</span></span><br><span class="line"></span><br><span class="line">+<span class="attr">NetObjectFilterDefinitions</span>=(FilterName=Spatial, ClassName=/Script/IrisCore.NetObjectGridFilter, ConfigClassName=/Script/IrisCore.NetObjectGridFilterConfig)</span><br><span class="line"></span><br><span class="line">+<span class="attr">NetObjectFilterDefinitions</span>=(FilterName=NotRouted, ClassName=/Script/IrisCore.FilterOutNetObjectFilter, ConfigClassName=/Script/IrisCore.FilterOutNetObjectFilterConfig)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[/Script/IrisCore.ReplicationStateDescriptorConfig]</span></span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=GameplayCueParameters)</span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=GameplayAbilityTargetData_LocationInfo)</span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=GameplayAbilityTargetData_ActorArray)</span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=GameplayAbilityTargetData_SingleTargetHit)</span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=LyraGameplayAbilityTargetData_SingleTargetHit)</span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=NetLevelVisibilityTransactionId)</span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=Vector2D)</span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=GameplayDebuggerNetPack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[/Script/IrisCore.ObjectReplicationBridgeConfig]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">DefaultSpatialFilterName</span>=Spatial</span><br><span class="line"></span><br><span class="line">!<span class="attr">FilterConfigs</span>=ClearArray</span><br><span class="line"></span><br><span class="line">+<span class="attr">FilterConfigs</span>=(ClassName=/Script/Engine.LevelScriptActor, DynamicFilterName=NotRouted) <span class="comment">; Not needed</span></span><br><span class="line"></span><br><span class="line">+<span class="attr">FilterConfigs</span>=(ClassName=/Script/Engine.Actor, DynamicFilterName=None))</span><br><span class="line"></span><br><span class="line">+<span class="attr">FilterConfigs</span>=(ClassName=/Script/Engine.Info, DynamicFilterName=None)</span><br><span class="line"></span><br><span class="line">+<span class="attr">FilterConfigs</span>=(ClassName=/Script/Engine.PlayerState, DynamicFilterName=None)</span><br><span class="line"></span><br><span class="line">+<span class="attr">FilterConfigs</span>=(ClassName=/Script/Engine.Pawn, DynamicFilterName=Spatial))</span><br><span class="line"></span><br><span class="line">+<span class="attr">FilterConfigs</span>=(ClassName=/Script/EntityActor.SimObject, DynamicFilterName=None))</span><br><span class="line"></span><br><span class="line">+<span class="attr">PrioritizerConfigs</span>=(ClassName=/Script/Engine.PlayerState, PrioritizerName=PlayerState)</span><br><span class="line"></span><br><span class="line">+<span class="attr">DeltaCompressionConfigs</span>=(ClassName=/Script/Engine.Pawn))</span><br><span class="line"></span><br><span class="line">+<span class="attr">DeltaCompressionConfigs</span>=(ClassName=/Script/Engine.PlayerState))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义-Replication-Bridge"><a href="#自定义-Replication-Bridge" class="headerlink" title="自定义 Replication Bridge"></a>自定义 Replication Bridge</h3><p>DefaultEngine.ini</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[Script/你的NetDriver]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ReplicationBridgeClassName</span>=你的ReplicationBridge类</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不配置则使用 UActorReplicationBridge</p>
<h3 id="默认使用-ReplicateSubObjectList"><a href="#默认使用-ReplicateSubObjectList" class="headerlink" title="默认使用 ReplicateSubObjectList"></a>默认使用 ReplicateSubObjectList</h3><p>DefaultEngine.ini</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[SystemSettings]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">net.SubObjects.DefaultUseSubObjectReplicationList</span>=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有设置这个，则会使用默认版本的 ReplicateSubobjects 函数来同步</p>
<p>因为 Iris 使用 SubObjectReplicationList 来同步，所以如果没有配置的话，会弹出 Ensure</p>
<p>并 Log Warning LogIrisBridge</p>
<h3 id="启动时"><a href="#启动时" class="headerlink" title="启动时"></a>启动时</h3><p>命令行参数添加</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-UseIrisReplication=1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者</p>
<p>控制台修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">net.Iris.UseIrisReplication1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者在 PostEngineInit 回调中加入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifUE_WITH_IRIS</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Iris 使用 Iris Replication</span></span><br><span class="line"></span><br><span class="line">    UE::Net::<span class="built_in">SetUseIrisReplication</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动项目后，开始成功同步</p>
<h1 id="配置类型分析"><a href="#配置类型分析" class="headerlink" title="配置类型分析"></a>配置类型分析</h1><p>现在我们来分析配置中用到的类型，从而为学习 Iris 同步的实现方式找一个抓手</p>
<h3 id="配置项同步桥配置-UObjectReplicationBridgeConfig"><a href="#配置项同步桥配置-UObjectReplicationBridgeConfig" class="headerlink" title="配置项同步桥配置 UObjectReplicationBridgeConfig"></a>配置项同步桥配置 UObjectReplicationBridgeConfig</h3><p>此类型用于每种不同的类型的过滤和优先级等配置</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[/Script/IrisCore.ObjectReplicationBridgeConfig]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">DefaultSpatialFilterName</span>=Spatial</span><br><span class="line"></span><br><span class="line">!<span class="attr">FilterConfigs</span>=ClearArray</span><br><span class="line"></span><br><span class="line">+<span class="attr">FilterConfigs</span>=(ClassName=/Script/Engine.LevelScriptActor, DynamicFilterName=NotRouted) <span class="comment">; Not needed</span></span><br><span class="line"></span><br><span class="line">+<span class="attr">FilterConfigs</span>=(ClassName=/Script/Engine.Actor, DynamicFilterName=None))</span><br><span class="line"></span><br><span class="line">+<span class="attr">FilterConfigs</span>=(ClassName=/Script/Engine.Info, DynamicFilterName=None)</span><br><span class="line"></span><br><span class="line">+<span class="attr">FilterConfigs</span>=(ClassName=/Script/Engine.PlayerState, DynamicFilterName=None)</span><br><span class="line"></span><br><span class="line">+<span class="attr">FilterConfigs</span>=(ClassName=/Script/Engine.Pawn, DynamicFilterName=Spatial))</span><br><span class="line"></span><br><span class="line">+<span class="attr">FilterConfigs</span>=(ClassName=/Script/EntityActor.SimObject, DynamicFilterName=None))</span><br><span class="line"></span><br><span class="line">+<span class="attr">PrioritizerConfigs</span>=(ClassName=/Script/Engine.PlayerState, PrioritizerName=PlayerState)</span><br><span class="line"></span><br><span class="line">+<span class="attr">DeltaCompressionConfigs</span>=(ClassName=/Script/Engine.Pawn))</span><br><span class="line"></span><br><span class="line">+<span class="attr">DeltaCompressionConfigs</span>=(ClassName=/Script/Engine.PlayerState))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从配置内容来看，此类似于 Replication Graph 中初始化各 Actor 的同步节点，同步优先级等内容</p>
<p>用于控制不同类型的对象，在同步的时候同步到哪一些连接，以及同步优先级，压缩等内容</p>
<p>现在进一步查看类型里面的可配置成员</p>
<h4 id="同步轮询周期"><a href="#同步轮询周期" class="headerlink" title="同步轮询周期"></a>同步轮询周期</h4><p>用于控制类型查询是否需要同步的帧数周期</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 同步轮询周期配置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Config)</span><br><span class="line"></span><br><span class="line">TArray&lt;FObjectReplicationBridgePollConfig&gt; PollConfigs;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中具体配置有</p>
<ul>
<li>ClassName：使用此配置的类型，Actor 以及 UObject 不允许配置</li>
<li>PollFramePeriod：轮询间隔帧数</li>
<li>bIncludeSubclasses：是否对子类用相同配置</li>
</ul>
<h4 id="类型过滤器配置"><a href="#类型过滤器配置" class="headerlink" title="类型过滤器配置"></a>类型过滤器配置</h4><p>用于控制类型的角色需要同步到哪些连接，例如分块同步</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 过滤器配置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Config)</span><br><span class="line"></span><br><span class="line">TArray&lt;FObjectReplicationBridgeFilterConfig&gt; FilterConfigs;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中具体配置有</p>
<ul>
<li>ClassName：使用此配置的类型</li>
<li>DynamicFilterName：过滤器名称</li>
</ul>
<h4 id="同步优先级配置"><a href="#同步优先级配置" class="headerlink" title="同步优先级配置"></a>同步优先级配置</h4><p>用于配置类型同步的优先级，例如距离优先等</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 同步优先级配置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Config)</span><br><span class="line"></span><br><span class="line">TArray&lt;FObjectReplicationBridgePrioritizerConfig&gt; PrioritizerConfigs;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中具体配置有</p>
<ul>
<li>ClassName：使用此配置的类型</li>
<li>PrioritizerName：使用的优先级控制器名称，Default 会使用默认 spatial prioritizer</li>
</ul>
<h4 id="增量同步压缩配置"><a href="#增量同步压缩配置" class="headerlink" title="增量同步压缩配置"></a>增量同步压缩配置</h4><p>用于控制是否开启类型的增量同步压缩</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 增量压缩相关配置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Config)</span><br><span class="line"></span><br><span class="line">TArray&lt;FObjectReplicationBridgeDeltaCompressionConfig&gt; DeltaCompressionConfigs;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中具体的配置有</p>
<ul>
<li>ClassName：使用此配置的类型</li>
<li>bEnableDeltaCompression：是否使用增量压缩（子类都会使用此配置）</li>
</ul>
<h4 id="默认分块同步的过滤器名称"><a href="#默认分块同步的过滤器名称" class="headerlink" title="默认分块同步的过滤器名称"></a>默认分块同步的过滤器名称</h4><p>由此可知，Iris 的默认同步过滤逻辑还是分块</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Config)</span><br><span class="line"></span><br><span class="line">FName DefaultSpatialFilterName;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="需要的-NetDriverChannel-名称"><a href="#需要的-NetDriverChannel-名称" class="headerlink" title="需要的 NetDriverChannel 名称"></a>需要的 NetDriverChannel 名称</h4><p>必须要使用的 NetDriverChannel 名称，按注释必须要有这个配置的 Channel 才能让此配置生效，但我没有找到这个逻辑生效的地方</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Config)</span><br><span class="line"></span><br><span class="line">FName RequiredNetDriverChannelClassName;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="配置项过滤器定义-UNetObjectFilterDefinitions"><a href="#配置项过滤器定义-UNetObjectFilterDefinitions" class="headerlink" title="配置项过滤器定义 UNetObjectFilterDefinitions"></a>配置项过滤器定义 UNetObjectFilterDefinitions</h3><p>此类型用于配置过滤器列表的定义</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[/Script/IrisCore.NetObjectFilterDefinitions]</span></span><br><span class="line"></span><br><span class="line">+<span class="attr">NetObjectFilterDefinitions</span>=(FilterName=Spatial, ClassName=/Script/IrisCore.NetObjectGridFilter, ConfigClassName=/Script/IrisCore.NetObjectGridFilterConfig)</span><br><span class="line"></span><br><span class="line">+<span class="attr">NetObjectFilterDefinitions</span>=(FilterName=NotRouted, ClassName=/Script/IrisCore.FilterOutNetObjectFilter, ConfigClassName=/Script/IrisCore.FilterOutNetObjectFilterConfig)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>FilterName ：上面 UObjectReplicationBridgeConfig 中用到的过滤器 Name</li>
<li>ClassName ：过滤器类型</li>
<li>ConfigClassName ：过滤器配置的类型</li>
</ul>
<hr>
<h3 id="过滤器基类-UNetObjectFilter"><a href="#过滤器基类-UNetObjectFilter" class="headerlink" title="过滤器基类 UNetObjectFilter"></a>过滤器基类 UNetObjectFilter</h3><p>过滤器类型用于处理那些对象同步到哪些连接的问题</p>
<p>类型中声明了一些可覆写的空函数</p>
<p>包括初始化，添加连接，移除连接，添加同步对象，移除同步对象，以及过滤相关的内容</p>
<p>我们可以通过实现自己的过滤逻辑来自定义同步规则，类似于 Replication Graph 中的同步节点编写</p>
<p>下面我们看一些具体的实现类型</p>
<h4 id="默认分块同步过滤器-UNetObjectGridFilter"><a href="#默认分块同步过滤器-UNetObjectGridFilter" class="headerlink" title="默认分块同步过滤器 UNetObjectGridFilter"></a>默认分块同步过滤器 UNetObjectGridFilter</h4><p>实现目的应该是同 Replication Graph 的分块同步</p>
<p>使用网络裁切距离和位置，确定对象可以被同步的 Grid Cell 列表</p>
<h4 id="过滤所有过滤器-UFilterOutNetObjectFilter"><a href="#过滤所有过滤器-UFilterOutNetObjectFilter" class="headerlink" title="过滤所有过滤器 UFilterOutNetObjectFilter"></a>过滤所有过滤器 UFilterOutNetObjectFilter</h4><p>过滤掉所有东西，不同步</p>
<h4 id="不过滤任何内容-UNopNetObjectFilter"><a href="#不过滤任何内容-UNopNetObjectFilter" class="headerlink" title="不过滤任何内容 UNopNetObjectFilter"></a>不过滤任何内容 UNopNetObjectFilter</h4><p>不过滤任何东西，全部同步</p>
<hr>
<h3 id="过滤器配置基类-UNetObjectFilterConfig"><a href="#过滤器配置基类-UNetObjectFilterConfig" class="headerlink" title="过滤器配置基类 UNetObjectFilterConfig"></a>过滤器配置基类 UNetObjectFilterConfig</h3><p>这是每种过滤器配置的积累，单独提出一个类型，可以方便的在 DefaultEngine.ini 中进行配置</p>
<p>当前有以下类型</p>
<h4 id="分块同步配置-UNetObjectGridFilterConfig"><a href="#分块同步配置-UNetObjectGridFilterConfig" class="headerlink" title="分块同步配置 UNetObjectGridFilterConfig"></a>分块同步配置 UNetObjectGridFilterConfig</h4><p>用于分块同步过滤器，配置分块大小，最大默认同步距离等</p>
<h4 id="过滤任何内容-UFilterOutNetObjectFilterConfig"><a href="#过滤任何内容-UFilterOutNetObjectFilterConfig" class="headerlink" title="过滤任何内容 UFilterOutNetObjectFilterConfig"></a>过滤任何内容 UFilterOutNetObjectFilterConfig</h4><p>无需配置，占位，其实无用</p>
<h4 id="不过滤任何内容-UNopNetObjectFilterConfig"><a href="#不过滤任何内容-UNopNetObjectFilterConfig" class="headerlink" title="不过滤任何内容 UNopNetObjectFilterConfig"></a>不过滤任何内容 UNopNetObjectFilterConfig</h4><p>无需配置，占位，其实无用</p>
<hr>
<h3 id="配置项优先级控制器定义-UNetObjectPrioritizerDefinitions"><a href="#配置项优先级控制器定义-UNetObjectPrioritizerDefinitions" class="headerlink" title="配置项优先级控制器定义 UNetObjectPrioritizerDefinitions"></a>配置项优先级控制器定义 UNetObjectPrioritizerDefinitions</h3><p>用于定义项目中的优先级控制器</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[/Script/IrisCore.NetObjectPrioritizerDefinitions]</span></span><br><span class="line"></span><br><span class="line">+<span class="attr">NetObjectPrioritizerDefinitions</span>=(PrioritizerName=Default, ClassName=/Script/IrisCore.SphereNetObjectPrioritizer, ConfigClassName=/Script/IrisCore.SphereNetObjectPrioritizerConfig)</span><br><span class="line"></span><br><span class="line">+<span class="attr">NetObjectPrioritizerDefinitions</span>=(PrioritizerName=PlayerState, ClassName=/Script/IrisCore.NetObjectCountLimiter, ConfigClassName=/Script/Engine.PlayerStateCountLimiterConfig)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中配置项</p>
<ul>
<li>PrioritizerName ：配置的优先级处理器名称，用于配置 Replication Bridge</li>
<li>ClassName ：同步器的类型</li>
<li>ConfigClassName ：同步器的配置类型</li>
</ul>
<hr>
<h3 id="优先级处理器基类-UNetObjectPrioritizer"><a href="#优先级处理器基类-UNetObjectPrioritizer" class="headerlink" title="优先级处理器基类 UNetObjectPrioritizer"></a>优先级处理器基类 UNetObjectPrioritizer</h3><p>用于处理同步对象的优先级</p>
<p>同过滤器基类，有一些空的虚函数，可自行扩展</p>
<p>我们来看一些具体类型</p>
<h4 id="ULocationBasedNetObjectPrioritizer"><a href="#ULocationBasedNetObjectPrioritizer" class="headerlink" title="ULocationBasedNetObjectPrioritizer"></a>ULocationBasedNetObjectPrioritizer</h4><p>基于位置的优先级处理器，没有实际处理优先级的部分，只是处理了位置信息的设置，所以只作为基类存在</p>
<h4 id="USphereNetObjectPrioritizer"><a href="#USphereNetObjectPrioritizer" class="headerlink" title="USphereNetObjectPrioritizer"></a>USphereNetObjectPrioritizer</h4><p>ULocationBasedNetObjectPrioritizer 的子类</p>
<p>会根据不同个数的 View 位置来进行不同的优先级设置</p>
<p>总体来说是根据和 View 的距离来设置不同的优先级，在一定范围内则优先级高，在外则低，一定距离外非常低</p>
<h4 id="USphereWithOwnerBoostNetObjectPrioritizer"><a href="#USphereWithOwnerBoostNetObjectPrioritizer" class="headerlink" title="USphereWithOwnerBoostNetObjectPrioritizer"></a>USphereWithOwnerBoostNetObjectPrioritizer</h4><p>USphereNetObjectPrioritizer 的子类</p>
<p>在其基础上，对于 Connection 的 Owning Object 附加一定的优先级</p>
<h4 id="UNetObjectCountLimiter"><a href="#UNetObjectCountLimiter" class="headerlink" title="UNetObjectCountLimiter"></a>UNetObjectCountLimiter</h4><p>根据配置的对象个数来限制同步频率</p>
<p>有两种模式</p>
<ul>
<li>RoundRobin : 每次同步轮流同步后面的 N 个对象</li>
<li>Fill ：每次同步的时候，同步最久没有被同步的 N 个对象</li>
</ul>
<h4 id="UPlayerStateCountLimiterConfig"><a href="#UPlayerStateCountLimiterConfig" class="headerlink" title="UPlayerStateCountLimiterConfig"></a>UPlayerStateCountLimiterConfig</h4><p>UNetObjectCountLimiter 的子类，作为同步 PlayerState 的 Limiter</p>
<p>没有具体逻辑，只是对父类的一些参数做特化</p>
<hr>
<h3 id="优先级处理器配置类-UNetObjectPrioritizerConfig"><a href="#优先级处理器配置类-UNetObjectPrioritizerConfig" class="headerlink" title="优先级处理器配置类 UNetObjectPrioritizerConfig"></a>优先级处理器配置类 UNetObjectPrioritizerConfig</h3><p>用于配置优先级处理器的 Config，与过滤器 Config 类似</p>
<p>每种优先级处理器都有其专用的类型</p>
<p>具体的子类此略</p>
<hr>
<h3 id="配置项数据流定义-UDataStreamDefinitions"><a href="#配置项数据流定义-UDataStreamDefinitions" class="headerlink" title="配置项数据流定义 UDataStreamDefinitions"></a>配置项数据流定义 UDataStreamDefinitions</h3><p>Iris 使用数据流 DataStream 的方式来在 Bunch 的基础上传输数据</p>
<p>在这个里面，我们定义项目中使用到的数据流类型</p>
<p>在启用 Iris 之后，数据同步内容均经由 ReplicationDataStream 来传输</p>
<p>其中配置如下</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[/Script/IrisCore.DataStreamDefinitions]</span></span><br><span class="line"></span><br><span class="line">+<span class="attr">DataStreamDefinitions</span>=(DataStreamName=NetToken, ClassName=/Script/IrisCore.NetTokenDataStream, DefaultSendStatus=EDataStreamSendStatus::Send, bAutoCreate=<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">+<span class="attr">DataStreamDefinitions</span>=(DataStreamName=Replication, ClassName=/Script/IrisCore.ReplicationDataStream, DefaultSendStatus=EDataStreamSendStatus::Send, bAutoCreate=<span class="literal">true</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>DataStreamName ：数据流名称</li>
<li>ClassName : 数据流的类</li>
<li>DefaultSendStatus：创建时默认的发送状态</li>
<li>bAutoCreate：是否为每个连接自动创建，如果不是 true 则需要手动创建</li>
</ul>
<hr>
<h3 id="配置项-NetBlob-处理器定义-UNetBlobHandlerDefinitions"><a href="#配置项-NetBlob-处理器定义-UNetBlobHandlerDefinitions" class="headerlink" title="配置项 NetBlob 处理器定义 UNetBlobHandlerDefinitions"></a>配置项 NetBlob 处理器定义 UNetBlobHandlerDefinitions</h3><p>Iris 在传输上使用数据块 FNetBlob 来传输</p>
<p>每个 NetBlob 会有一个 FNetBlobCreationInfo CreationInfo 来标识其创建 Flag 和 Blob 的类型</p>
<p>以便使用特定的 Blob 处理器来处理</p>
<p>此处配置 NetBlob 的处理器定义列表</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[/Script/IrisCore.NetBlobHandlerDefinitions]</span></span><br><span class="line"></span><br><span class="line">+<span class="attr">NetBlobHandlerDefinitions</span>=(ClassName=NetRPCHandler)</span><br><span class="line"></span><br><span class="line">+<span class="attr">NetBlobHandlerDefinitions</span>=(ClassName=PartialNetObjectAttachmentHandler )</span><br><span class="line"></span><br><span class="line">+<span class="attr">NetBlobHandlerDefinitions</span>=(ClassName=NetObjectBlobHandler)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>UNetPRCHandler 用于处理 RPC</li>
<li>PartialNetObjectAttachmentHandler 用于处理分块大型 Blob</li>
<li>UNetObjectBlobHandler 用于处理 NetObjectBlob</li>
</ul>
<hr>
<h3 id="使用的同步-Channel-DataStreamChannel"><a href="#使用的同步-Channel-DataStreamChannel" class="headerlink" title="使用的同步 Channel DataStreamChannel"></a>使用的同步 Channel DataStreamChannel</h3><p>Iris 使用 DataSteam Channel 用于同步数据流</p>
<p>所以需要添加配置</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[/Script/Engine.NetDriver]</span></span><br><span class="line"></span><br><span class="line">+<span class="attr">ChannelDefinitions</span>=(ChannelName=DataStream, ClassName=/Script/Engine.DataStreamChannel, StaticChannelIndex=<span class="number">2</span>, bTickOnCreate=<span class="literal">true</span>, bServerOpen=<span class="literal">true</span>, bClientOpen=<span class="literal">true</span>, bInitialServer=<span class="literal">true</span>, bInitialClient=<span class="literal">true</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 NetDriver 上添加 DataStreamChannel 以开启通道</p>
<hr>
<h3 id="配置项自定义序列化-UReplicationStateDescriptorConfig"><a href="#配置项自定义序列化-UReplicationStateDescriptorConfig" class="headerlink" title="配置项自定义序列化 UReplicationStateDescriptorConfig"></a>配置项自定义序列化 UReplicationStateDescriptorConfig</h3><p>配置 Struct 是否可以使用 Iris 默认的 StructNetSerializer</p>
<p>因为 Iris 在序列化 Struct 的时候，会默认使用 StructNetSerializer</p>
<p>如果需要自定义序列化的话，用从前的 TStructOpsTypeTraits WithNetSerializer Trait 是不行的</p>
<p>需要自己去使用 UE_NET_IMPLEMENT_SERIALIZER 来定义自定义序列化处理器</p>
<p>如果有使用了 WithNetSerializer Trait 自定义序列化的内容，却没有用新的方式去实现的话，会提示 Warning</p>
<p>所以这个配置仅用于使用了 NetSerialize Trait</p>
<p>但是可以使用 Iris 自己创建的同步信息</p>
<p>不想要提示 Warning 的情况</p>
<p>如果提示 Warning 了，可检查对应 Struct 的同步功能是否正常，正常则加入此配置中</p>
<p>否则需要重新写自己的对应类型的 Serializer</p>
<p>配置如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[/Script/IrisCore.ReplicationStateDescriptorConfig]</span></span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=GameplayCueParameters)</span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=GameplayAbilityTargetData_LocationInfo)</span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=GameplayAbilityTargetData_ActorArray)</span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=GameplayAbilityTargetData_SingleTargetHit)</span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=LyraGameplayAbilityTargetData_SingleTargetHit)</span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=NetLevelVisibilityTransactionId)</span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=Vector2D)</span><br><span class="line"></span><br><span class="line">+<span class="attr">SupportsStructNetSerializerList</span>=(StructName=GameplayDebuggerNetPack)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>本文通过对成功启动 Iris 的配置的内容分析</p>
<p>揭开了 Iris 机制的冰山一角</p>
<p>后续我将继续分享 Iris 同步的其他内容</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mapz.github.io/2023/02/10/UE5%EF%BC%9A%E7%AE%80%E8%BF%B0Gauntlet%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/link-300x300.gif">
      <meta itemprop="name" content="Mapz">
      <meta itemprop="description" content="FIND THE CHILD">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mapz's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/10/UE5%EF%BC%9A%E7%AE%80%E8%BF%B0Gauntlet%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">UE5：简述Gauntlet的原理和使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-10 16:46:09" itemprop="dateCreated datePublished" datetime="2023-02-10T16:46:09+08:00">2023-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-14 18:00:53" itemprop="dateModified" datetime="2023-02-14T18:00:53+08:00">2023-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是-Gauntlet"><a href="#什么是-Gauntlet" class="headerlink" title="什么是 Gauntlet"></a>什么是 Gauntlet</h1><p>Gauntlet <a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/en-US/TestingAndOptimization/Automation/Gauntlet/">官方文档</a></p>
<p>简而言之，Gauntlet 提供支持来启动多个实例来进行测试，例如常见的 Dedicated Server 测试，需要一个服务器和多个客户端</p>
<p>但是 Gauntlet 并不关心测试的内容，只提供一个需要开发者实现的 GauntletTestController 来控制测试的流程</p>
<p>所以 Gauntlet 的侧重点在于 <strong>组织单个或多个实例</strong> ，而非测试的 <strong>内容和形式</strong>（包括使用的测试框架，测试的内容等）</p>
<p>具体的测试可以由开发者自己编写的 GauntletTestController 以 <strong>任意方式</strong> 来测试 <strong>任意内容</strong></p>
<h1 id="本文的开发环境"><a href="#本文的开发环境" class="headerlink" title="本文的开发环境"></a>本文的开发环境</h1><p>操作系统：windows 11</p>
<p>引擎：UE 5.0 源码版本</p>
<p>IDE：Rider for Unreal</p>
<h1 id="Gauntlet-的原理"><a href="#Gauntlet-的原理" class="headerlink" title="Gauntlet 的原理"></a>Gauntlet 的原理</h1><h2 id="两个部分"><a href="#两个部分" class="headerlink" title="两个部分"></a>两个部分</h2><p>Gauntlet 分为两个部分</p>
<ul>
<li>游戏外自动化部分，属于 AutomationTool</li>
<li>游戏内 Runtime 部分，属于 Gauntlet 插件，通过 Gauntlet Test Controller 驱动游戏内逻辑</li>
</ul>
<p>其中游戏外部分，控制游戏实例的参数和启动</p>
<p>游戏内部分，控制具体的测试逻辑</p>
<h2 id="什么是-AutomationTool"><a href="#什么是-AutomationTool" class="headerlink" title="什么是 AutomationTool"></a>什么是 AutomationTool</h2><p>AutomationTool <a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/BuildTools/AutomationTool/">官方文档</a></p>
<p>AutomationTool 可简称 UAT</p>
<p>是虚幻引擎中用于自动化流水线的一套工具，主要用于 Build 项目和测试等，这套工具由 C# 编写</p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;%EnginePath%\Engine\Build\BatchFiles\RunUAT&quot;</span><br></pre></td></tr></table></figure>

<p>即可执行 Automation 命令，命令的基类为</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BuildCommand</span> : <span class="title">CommandUtils</span></span><br></pre></td></tr></table></figure>

<p>开发者也可以自己添加 Automation 项目</p>
<p>在其中添加相关 Automation 中需要的自定义类型，或者继承 BuildCommand 为 UAT 添加自定义命令</p>
<p>Automation 项目都需要以 XXX.Automation 来命名，且放在 [ProjectDir]\Build 或 [EngineDir]\Source\Programs 目录下</p>
<p>Build 时需要使用源码版本的引擎，从而在每次 Build 的时候重新生成自定义 Automation 项目的 dll</p>
<h2 id="Gauntlet-Automation-游戏外自动化部分"><a href="#Gauntlet-Automation-游戏外自动化部分" class="headerlink" title="Gauntlet.Automation 游戏外自动化部分"></a>Gauntlet.Automation 游戏外自动化部分</h2><p>Gauntlet 正是 Automation 中的一个项目，也就是上文所说的游戏外自动化部分</p>
<img src="/2023/02/10/UE5%EF%BC%9A%E7%AE%80%E8%BF%B0Gauntlet%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/Guantlet%E9%A1%B9%E7%9B%AE.png" class title="项目目录">

<h3 id="RunUnreal-命令"><a href="#RunUnreal-命令" class="headerlink" title="RunUnreal 命令"></a>RunUnreal 命令</h3><p>Gauntlet 项目提供了 RunUnreal 命令来进行 Gauntlet 测试</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RunUnreal</span> : <span class="title">BuildCommand</span></span><br></pre></td></tr></table></figure>

<p><strong>命令入口</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ExitCode <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Globals.Params = <span class="keyword">new</span> Gauntlet.Params(<span class="keyword">this</span>.Params);</span><br><span class="line"></span><br><span class="line">	UnrealTestOptions ContextOptions = <span class="keyword">new</span> UnrealTestOptions();</span><br><span class="line">	<span class="comment">// 附加载各种参数到 Context 中</span></span><br><span class="line">	AutoParam.ApplyParamsAndDefaults(ContextOptions, Globals.Params.AllArguments);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(ContextOptions.Project))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AutomationException(<span class="string">&quot;No project specified. Use -project=ShooterGame etc&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ContextOptions.Namespaces = <span class="string">&quot;Gauntlet.UnrealTest,UnrealGame,UnrealEditor&quot;</span>;</span><br><span class="line">	ContextOptions.UsesSharedBuildType = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 开始测试</span></span><br><span class="line">	<span class="keyword">return</span> RunTests(ContextOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试参数 Context</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnrealTestOptions</span> : <span class="title">TestExecutorOptions</span>,  <span class="title">IAutoParamNotifiable</span></span><br></pre></td></tr></table></figure>

<p>其中就包含了上面所说的启动多个实例需要用到的包括 Platform 类型、Build 类型、包文件地址、多个实例的 Build Target 类型、Role 类型（客户端还是服务器）、加载的地图之类的参数</p>
<p><strong>RunTest</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> ExitCode <span class="title">RunTests</span>(<span class="params">UnrealTestOptions ContextOptions</span>)</span></span><br></pre></td></tr></table></figure>

<p>包含测试逻辑， ExitCode 中会返回测试是否通过</p>
<p>执行函数时，会先根据我们传入的 Context 来查找存在的符合条件的可执行文件，然后打开一个或多个游戏实例来进行测试</p>
<p><strong>ExecuteTests</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">ExecuteTests</span>(<span class="params">UnrealTestOptions Options, IEnumerable&lt;ITestNode&gt; TestList</span>)</span></span><br></pre></td></tr></table></figure>

<p>具体测试逻辑入口，准备好实例的 Context 信息后，会传入测试列表，执行这个函数开始测试</p>
<h3 id="测试的具体CSharp类型"><a href="#测试的具体CSharp类型" class="headerlink" title="测试的具体CSharp类型"></a>测试的具体CSharp类型</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseTest</span> : <span class="title">ITestNode</span></span><br></pre></td></tr></table></figure>

<p>这个就是测试的基类，包含了测试所需的基本逻辑链条，在实际使用中，需要使用其子类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">UnrealTestNode</span>&lt;<span class="title">TConfigClass</span>&gt; : <span class="title">BaseTest</span>, <span class="title">IDisposable</span></span><br><span class="line">		<span class="keyword">where</span> <span class="title">TConfigClass</span> : <span class="title">UnrealTestConfiguration</span>, <span class="title">new</span>()</span><br></pre></td></tr></table></figure>

<p>来派生出开发者自己的测试类型，并在其中指定 Gauntlet Controller 和游戏实例配置等信息</p>
<p>这个类型中，还包括一些测试结果相关的功能，例如输入测试报告等</p>
<p>在实际使用的章节我们会继续提到这个类型</p>
<p>我们现在只需要知道，测试的列表，是通过 UAT 的命令行传入的</p>
<p><strong>启动实例</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">PrepareUnrealApp</span>(<span class="params"></span>)</span></span><br></pre></td></tr></table></figure>

<p>在测试 Node 开始测试的时候，这个函数会被执行，来启动游戏实例</p>
<p>在这个函数中，我们会发现上文所说的 <strong>两个部分</strong> 连接起来的秘密</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add controllers</span></span><br><span class="line">SessionRole.CommandLineParams.Add(<span class="string">&quot;gauntlet&quot;</span>, </span><br><span class="line">   TestRole.Controllers.Count &gt; <span class="number">0</span> ? <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, TestRole.Controllers) : <span class="literal">null</span>);   </span><br></pre></td></tr></table></figure>

<p>这里，把 Gauntlet Test Controller 通过命令行的形式，加入到了游戏实例的启动参数中！</p>
<p>也就是说游戏实例启动后，一定是去获取了 gauntlet=xxx,xxx,xxx 参数，来获得需要执行的 gauntlet test controller 列表</p>
<p>这个我们在后面再继续聊</p>
<p>当 Controller 准备好以后，最终执行了</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnrealApp = <span class="keyword">new</span> UnrealSession(Context.BuildInfo, SessionRoles) &#123; Sandbox = Context.Options.Sandbox &#125;;</span><br></pre></td></tr></table></figure>

<p>来启动实例</p>
<p>我们可以看到，这个实例是以 UnrealSession 的形式存在的</p>
<h3 id="UnrealSession"><a href="#UnrealSession" class="headerlink" title="UnrealSession"></a>UnrealSession</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnrealSession</span> : <span class="title">IDisposable</span></span><br></pre></td></tr></table></figure>

<p>Unreal Session 用于启动、监控、关闭游戏实例</p>
<h2 id="Gauntlet-游戏内插件部分"><a href="#Gauntlet-游戏内插件部分" class="headerlink" title="Gauntlet 游戏内插件部分"></a>Gauntlet 游戏内插件部分</h2><img src="/2023/02/10/UE5%EF%BC%9A%E7%AE%80%E8%BF%B0Gauntlet%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/Gauntlet%E6%8F%92%E4%BB%B6%E9%A1%B9%E7%9B%AE.png" class title="项目目录">

<p>可以看到，插件非常简单，基本就只有一个 Gauntlet Test Controller</p>
<p>并提供了两个示例 BootTest 和 Error Test</p>
<h3 id="加载-Gauntlet-命令行的位置"><a href="#加载-Gauntlet-命令行的位置" class="headerlink" title="加载 Gauntlet 命令行的位置"></a>加载 Gauntlet 命令行的位置</h3><p>GauntletModule.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FGauntletModuleImpl::OnPostEngineInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FCoreUObjectDelegates::PostLoadMapWithWorld.<span class="built_in">AddRaw</span>(<span class="keyword">this</span>, &amp;FGauntletModuleImpl::InnerPostMapChange);</span><br><span class="line">   FCoreUObjectDelegates::PreLoadMap.<span class="built_in">AddRaw</span>(<span class="keyword">this</span>, &amp;FGauntletModuleImpl::InnerPreMapChange);</span><br><span class="line"></span><br><span class="line">   FParse::<span class="built_in">Value</span>(FCommandLine::<span class="built_in">Get</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;gauntlet.screenshotperiod=&quot;</span>), ScreenshotPeriod);</span><br><span class="line">   FParse::<span class="built_in">Value</span>(FCommandLine::<span class="built_in">Get</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;gauntlet.heartbeatperiod=&quot;</span>), HeartbeatPeriod);</span><br><span class="line">   <span class="comment">// 加载 Controllers</span></span><br><span class="line">   <span class="built_in">LoadControllers</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">float</span> kTickRate = <span class="number">1.0f</span>;</span><br><span class="line">   FParse::<span class="built_in">Value</span>(FCommandLine::<span class="built_in">Get</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;gauntlet.tickrate=&quot;</span>), kTickRate);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   TickHandle = FTSTicker::<span class="built_in">GetCoreTicker</span>().<span class="built_in">AddTicker</span>(FTickerDelegate::<span class="built_in">CreateLambda</span>([<span class="keyword">this</span>, kTickRate](<span class="keyword">float</span> TimeDelta)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// ticker passes in frame-delta, not tick delta...</span></span><br><span class="line"><span class="built_in">InnerTick</span>(kTickRate);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;),</span><br><span class="line">   kTickRate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FGauntletModuleImpl::LoadControllers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FString ControllerString;</span><br><span class="line"></span><br><span class="line">   FParse::<span class="built_in">Value</span>(FCommandLine::<span class="built_in">Get</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;gauntlet=&quot;</span>), ControllerString, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (ControllerString.<span class="built_in">Len</span>())</span><br><span class="line">   &#123;</span><br><span class="line">      TArray&lt;FString&gt; ControllerNames;</span><br><span class="line"></span><br><span class="line">      ControllerString.<span class="built_in">ParseIntoArrayWS</span>(ControllerNames, <span class="built_in">TEXT</span>(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">      TSet&lt;FString&gt; ControllersToCreate;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> FString&amp; Name : ControllerNames)</span><br><span class="line">      &#123;</span><br><span class="line">         UClass* TestClass = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (TObjectIterator&lt;UClass&gt; It; It; ++It)</span><br><span class="line">         &#123;</span><br><span class="line">            UClass* Class = *It;</span><br><span class="line"></span><br><span class="line">            FString FullName = Name;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search for SomethingTestController and ControllerSomethingTest. The last is legacy</span></span><br><span class="line">FString PartialName1 = Name + <span class="built_in">TEXT</span>(<span class="string">&quot;Controller&quot;</span>);</span><br><span class="line">            FString PartialName2 = <span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Controller&quot;</span>)) + Name;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Class-&gt;IsChildOf&lt;UGauntletTestController&gt;())</span><br><span class="line">            &#123;</span><br><span class="line">               FString ClassName = Class-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">               <span class="keyword">if</span> (ClassName == FullName || ClassName.<span class="built_in">EndsWith</span>(PartialName1) || ClassName.<span class="built_in">EndsWith</span>(PartialName2))</span><br><span class="line">               &#123;</span><br><span class="line">                  <span class="comment">// Gauntlet has a couple of test classes, so need to differentiate between &quot;GauntletFooTest&quot; and &quot;GameFooTest&quot;.</span></span><br><span class="line">                  <span class="comment">// that will both be launched via -gauntlet=FooTest</span></span><br><span class="line"><span class="keyword">bool</span> GauntletDefault = ClassName.<span class="built_in">StartsWith</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Gauntlet&quot;</span>));</span><br><span class="line"></span><br><span class="line">                  TestClass = Class;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// If not gauntlet stop searching</span></span><br><span class="line"><span class="keyword">if</span> (!GauntletDefault)</span><br><span class="line">                  &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;  </span><br><span class="line"></span><br><span class="line">         <span class="built_in">checkf</span>(TestClass, <span class="built_in">TEXT</span>(<span class="string">&quot;Could not find class for controller %s&quot;</span>), *Name);</span><br><span class="line"></span><br><span class="line">         UGauntletTestController* NewController = NewObject&lt;UGauntletTestController&gt;(<span class="built_in">GetTransientPackage</span>(), TestClass);</span><br><span class="line"></span><br><span class="line">         <span class="built_in">check</span>(NewController);</span><br><span class="line"></span><br><span class="line">         <span class="built_in">UE_LOG</span>(LogGauntlet, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;Added Gauntlet controller %s&quot;</span>), *Name);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Important - add the controller first! Some controllers may trigger GC&#x27;s which would</span></span><br><span class="line">         <span class="comment">// then result in them being collected...</span></span><br><span class="line">Controllers.<span class="built_in">Add</span>(NewController);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> Controller : Controllers)</span><br><span class="line">   &#123;</span><br><span class="line">      Controller-&gt;<span class="built_in">OnInit</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 PostEngineInit 后，开始 LoadControllers</p>
<p>然后读取了命令行，并使用其名称，去获得 C++ 的相应类型</p>
<p>然后执行其 OnInit</p>
<h3 id="GauntletTestController-简析"><a href="#GauntletTestController-简析" class="headerlink" title="GauntletTestController 简析"></a>GauntletTestController 简析</h3><p>声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GAUNTLET_API</span> <span class="title">UGauntletTestController</span> :</span> <span class="keyword">public</span> UObject</span><br></pre></td></tr></table></figure>

<p>里面是一些简单的状态控制，几个处理函数都需要自己去实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>    <span class="title">OnInit</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called prior to a map change</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>   <span class="title">OnPreMapChange</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called after a map change. GetCurrentMap() will now return the new map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>   <span class="title">OnPostMapChange</span><span class="params">(UWorld* World)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called periodically to let the controller check and control state</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>   <span class="title">OnTick</span><span class="params">(<span class="keyword">float</span> TimeDelta)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when a state change is applied to the module. States are game-driven.</span></span><br><span class="line"><span class="comment"> * GetCurrentState() == OldState until this function returns</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>   <span class="title">OnStateChange</span><span class="params">(FName OldState, FName NewState)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>正所谓什么都没写，就有无限可能（狗头。</p>
<p>前面说的可以测试任何内容就是这个意思，你可以通过写一个自己的 TestController 来添加任何逻辑和接入任何测试框架。</p>
<p>从上面的 OnInit 那里就可以简单推测出，整个 TestController 是由 GauntletModuleImpl 来驱动的，事实呢也是如此，上面几个函数的调用都是在 GauntletModuleImpl 中。</p>
<h1 id="从零开始的Gauntlet实战"><a href="#从零开始的Gauntlet实战" class="headerlink" title="从零开始的Gauntlet实战"></a>从零开始的Gauntlet实战</h1><p>现在我们已经了解了 Gauntlet 的基本原理，那么现在我们从零开始使用 Gauntlet 搭建一个简单的测试</p>
<p>版本是 UE 5.0 源码编译版本</p>
<h2 id="搭建源码环境"><a href="#搭建源码环境" class="headerlink" title="搭建源码环境"></a>搭建源码环境</h2><p>因为编译 Automation 项目需要源码版本的引擎，所以需要搭建源码环境</p>
<h2 id="创建一个新的游戏项目"><a href="#创建一个新的游戏项目" class="headerlink" title="创建一个新的游戏项目"></a>创建一个新的游戏项目</h2><p>这里我们选择 First Person 模版，创建一个 C++ 项目，取名 GauntletTutorial</p>
<p>然后把项目依赖的引擎版本设置为源码，编译启动编辑器</p>
<p>打开 Plugin 设置，启用 Gauntlet 插件</p>
<p>因为我们测试的时候需要启动 Server 和 Client 实例，所以我们需要在项目中添加 Server Build Target 以及 Client Build Target</p>
<p>详见 <a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.1/en-US/setting-up-dedicated-servers-in-unreal-engine/">官网文档说明</a></p>
<p>我们这里只需要正确添加 GauntletTutorialServer.Target.cs 和 GauntletTutorialClient.Target.cs 两个文件即可</p>
<h2 id="制作-Automation-工程"><a href="#制作-Automation-工程" class="headerlink" title="制作 Automation 工程"></a>制作 Automation 工程</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.1/en-US/create-an-automation-project-in-unreal-engine/">官网文档说明</a></p>
<p>注：5.0 以前的版本和 5.0 以后的版本使用的 .Net 依赖不同，创建方式略有不同</p>
<p>我这里 IDE 使用 Rider ，使用 VS 的同学应该也差不太多</p>
<p>选择 File -&gt; New Solution -&gt; .Net/.Net Core -&gt; Class Library</p>
<p>填入你喜欢的项目名称，记住之前说过的两个规则</p>
<ol>
<li>项目以 XXX.Automation 命名</li>
<li>项目放在 [ProjectDir]\Build 下</li>
</ol>
<p>我们这里在 [ProjectDir]\Build 目录下创建一个 Gauntlet 目录，把我们的项目放进去</p>
<p>然后 Framework 选择 netcoreapp3.1</p>
<p>勾上 Put Solution and project in the same directory</p>
<img src="/2023/02/10/UE5%EF%BC%9A%E7%AE%80%E8%BF%B0Gauntlet%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/%E5%88%9B%E5%BB%BAAutomation.png" class title="创建Automation">

<p>点击创建生成项目</p>
<h3 id="编写一个测试"><a href="#编写一个测试" class="headerlink" title="编写一个测试"></a>编写一个测试</h3><p>原理部分讲到，我们的每个测试都是继承自</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">UnrealTestNode</span>&lt;<span class="title">TConfigClass</span>&gt; : <span class="title">BaseTest</span>, <span class="title">IDisposable</span></span><br><span class="line"><span class="keyword">where</span> <span class="title">TConfigClass</span> : <span class="title">UnrealTestConfiguration</span>, <span class="title">new</span>()</span><br></pre></td></tr></table></figure>

<p>的一个子类</p>
<p>其中，TConfigClass 是我们测试使用的配置类型，继承自 UnrealTestConfiguration</p>
<p>我们现在来创建一个自己的测试</p>
<p>修改默认创建的 Class1 ，改名为 GauntletTutorialTest，并使用 UnrealTestConfig 类型作为配置，类声明如下</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GauntletTutorialTest</span> : <span class="title">UnrealTestNode</span>&lt;<span class="title">UnrealTestConfig</span>&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到 IDE 提示缺少依赖，我们需要引入 Gauntlet.Automation 项目作为依赖</p>
<p>项目目录右键点击 Dependence ，打开 Reference</p>
<img src="/2023/02/10/UE5%EF%BC%9A%E7%AE%80%E8%BF%B0Gauntlet%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/AddReference.png" class title="AddReference">

<p>点击 Add From</p>
<p>选择 [EnginePath]\unrealengine\Engine\Binaries\DotNET\AutomationScripts\netcoreapp3.1\Gauntlet.Automation.dll</p>
<img src="/2023/02/10/UE5%EF%BC%9A%E7%AE%80%E8%BF%B0Gauntlet%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/AddReference2.png" class title="AddReference2">

<p>然后修改代码，最终如下</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Gauntlet;</span><br><span class="line"><span class="keyword">using</span> UnrealGame;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GauntletTutorial.Automation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GauntletTutorialTest</span> : <span class="title">UnrealTestNode</span>&lt;<span class="title">UnrealTestConfig</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">GauntletTutorialTest</span>(<span class="params">UnrealTestContext inContext</span>) : <span class="title">base</span>(<span class="params">inContext</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在创建出了一个新的测试，但如何设置测试参数呢？答案是重写函数 GetConfiguration()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// Returns information about how to configure our Unreal processes. For the most part the majority</span><br><span class="line">/// of Unreal tests should only need to override this function</span><br><span class="line">/// &lt;/summary&gt;</span><br></pre></td></tr></table></figure>

<p>此函数的说明：大部分情况下，我们只需要重写这个函数就可以了</p>
<p>现在我们大致写一个测试配置</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> UnrealTestConfig <span class="title">GetConfiguration</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    UnrealTestConfig config = <span class="keyword">base</span>.GetConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个客户端和一个服务器</span></span><br><span class="line">    UnrealTestRole clientRole = config.RequireRole(UnrealTargetRole.Client);</span><br><span class="line">    UnrealTestRole serverRole = config.RequireRole(UnrealTargetRole.Server);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置一个最长测试时间（单位是秒，时间到了后会结束测试）</span></span><br><span class="line">    config.MaxDuration = <span class="number">60</span> * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时后，测试结果是成功还是失败</span></span><br><span class="line">    config.MaxDurationReachedResult = EMaxDurationReachedResult.Success;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给每个 Role 设定 GauntletTestController</span></span><br><span class="line">    <span class="comment">// 这里使用官方提供的 ErrorTest 来做一个测试</span></span><br><span class="line">    clientRole.Controllers.Add(<span class="string">&quot;GauntletTestControllerErrorTest&quot;</span>);</span><br><span class="line">    serverRole.Controllers.Add(<span class="string">&quot;GauntletTestControllerErrorTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过 Map 来修改测试地图</span></span><br><span class="line">    <span class="comment">// config.Map = &quot;TestMap&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以通过 Role 的 Map Override 来修改地图</span></span><br><span class="line">    <span class="comment">// clientRole.MapOverride = &quot;ClientMapOverride&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外除了这些配置，我们可以看到 UnrealTestConfig 和其父类中还有很多注解为 AutoParam 的变量</p>
<p>这些变量都可以通过 RunUnreal 的命令行参数来自动获取并赋值</p>
<p>在测试中，我们指定每个 Role 都执行系统自带的 GauntletTestControllerErrorTest 来测试</p>
<p>至此一个简单的测试就完成了</p>
<h2 id="运行编写好的测试"><a href="#运行编写好的测试" class="headerlink" title="运行编写好的测试"></a>运行编写好的测试</h2><p>通过之前的原理部分，我们知道，Gauntlet Automation 是去查找打好的可执行文件来运行的，所以运行前，应该保证你测试中的 Role 实例已经打好包了，例如 Server 就要打好服务器包</p>
<p>在 [ProjectDir] 下新建一个 Scripts 目录</p>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>新建一个批处理 Pack.bat 来进行打包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> ProjectPath=项目目录</span><br><span class="line"><span class="built_in">set</span> EnginePath=源码版引擎目录</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;%EnginePath%\Engine\Build\BatchFiles\RunUAT&quot;</span> BuildCookRun -project=%ProjectPath%\GauntletTutorial.uproject -platform=Win64 -configuration=Development -build -cook -pak -stage -server -client</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p>执行后，会打出 Client 和 Server 包，因为是源码构建，可能会花比较久的时间</p>
<h3 id="执行-RunUnreal"><a href="#执行-RunUnreal" class="headerlink" title="执行 RunUnreal"></a>执行 RunUnreal</h3><p>再新建一个批处理 RunGauntlet.bat</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> ProjectPath=项目目录</span><br><span class="line"><span class="built_in">set</span> StagingDir=%ProjectPath%\Saved\StagedBuilds\</span><br><span class="line"><span class="built_in">set</span> EnginePath=源码版引擎目录</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;%EnginePath%\Engine\Build\BatchFiles\RunUAT&quot;</span> RunUnreal -project=%ProjectPath%\GauntletTutorial.uproject -build=%StagingDir% -platform=Win64 -configuration=development -<span class="built_in">test</span>=GauntletTutorial.Automation.GauntletTutorialTest -scriptdir=%ProjectPath%</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p>其中 platform 和 configuration 一定更要和打包配置一致，否则会找不到目标可执行文件</p>
<p>build 参数选择打出来的包的目录</p>
<p>test 参数填入 Gauntlet Automation 测试的全名</p>
<p>运行后，我们可以看到，按照配置启动了一个客户端和一个服务器，如下</p>
<img src="/2023/02/10/UE5%EF%BC%9A%E7%AE%80%E8%BF%B0Gauntlet%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95.png" class title="执行测试">

<p>然后测试结果是失败</p>
<img src="/2023/02/10/UE5%EF%BC%9A%E7%AE%80%E8%BF%B0Gauntlet%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" class title="测试结果">

<p>原因是 GauntletTestControllerErrorTest 默认逻辑会在启动后立刻释放一个 check 让测试失败</p>
<h2 id="传入命令行参数到-Automation-项目和游戏实例中"><a href="#传入命令行参数到-Automation-项目和游戏实例中" class="headerlink" title="传入命令行参数到 Automation 项目和游戏实例中"></a>传入命令行参数到 Automation 项目和游戏实例中</h2><p>查看 UGauntletTestControllerErrorTest 的源码，我们可知这个测试会接受命令行参数，从而调用 check , ensure 等</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UGauntletTestControllerErrorTest::OnInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ErrorDelay = <span class="number">0</span>;</span><br><span class="line">   ErrorType = <span class="built_in">TEXT</span>(<span class="string">&quot;check&quot;</span>);</span><br><span class="line"></span><br><span class="line">   FParse::<span class="built_in">Value</span>(FCommandLine::<span class="built_in">Get</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;errortest.delay=&quot;</span>), ErrorDelay);</span><br><span class="line">   FParse::<span class="built_in">Value</span>(FCommandLine::<span class="built_in">Get</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;errortest.type=&quot;</span>), ErrorType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UGauntletTestControllerErrorTest::OnTick</span><span class="params">(<span class="keyword">float</span> TimeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">GetTimeInCurrentState</span>() &gt; ErrorDelay)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (ErrorType == <span class="built_in">TEXT</span>(<span class="string">&quot;ensure&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">UE_LOG</span>(LogGauntlet, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;Issuing ensure as requested&quot;</span>));</span><br><span class="line">         <span class="built_in">ensureMsgf</span>(<span class="literal">false</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Ensuring false....&quot;</span>));</span><br><span class="line">         <span class="built_in">EndTest</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ErrorType == <span class="built_in">TEXT</span>(<span class="string">&quot;check&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">UE_LOG</span>(LogGauntlet, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;Issuing failed check as requested&quot;</span>));</span><br><span class="line">         <span class="built_in">checkf</span>(<span class="literal">false</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Asserting as requested&quot;</span>));</span><br><span class="line">      &#125;   </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ErrorType == <span class="built_in">TEXT</span>(<span class="string">&quot;fatal&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">UE_LOG</span>(LogGauntlet, Fatal, <span class="built_in">TEXT</span>(<span class="string">&quot;Issuing fatal error as requested&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ErrorType == <span class="built_in">TEXT</span>(<span class="string">&quot;gpf&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PVS_STUDIO</span></span><br><span class="line">         <span class="built_in">UE_LOG</span>(LogGauntlet, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;Issuing GPF as requested&quot;</span>));</span><br><span class="line">         <span class="keyword">int</span>* Ptr = (<span class="keyword">int</span>*)<span class="number">0</span>;</span><br><span class="line">         <span class="built_in">CA_SUPPRESS</span>(<span class="number">6011</span>);</span><br><span class="line">         *Ptr = <span class="number">42</span>; <span class="comment">// -V522</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// PVS_STUDIO</span></span></span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">         <span class="built_in">UE_LOG</span>(LogGauntlet, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;No recognized error request. Failing test&quot;</span>));</span><br><span class="line">         <span class="built_in">EndTest</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们怎么样才能从 Gauntlet 传入命令行参数到游戏呢？</p>
<h3 id="官方例子-Nullrhi-参数"><a href="#官方例子-Nullrhi-参数" class="headerlink" title="官方例子 Nullrhi 参数"></a>官方例子 Nullrhi 参数</h3><p>下面我们参考 UnrealTestConfiguration 是如何把 Nullrhi 这个参数传入游戏中的</p>
<p>我们回到 Automation 项目中，查看类型 我们使用的配置类型 UnrealTestConfig 的基类 Gauntlet.UnrealTestConfiguration</p>
<p>其中有一个函数是</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ApplyToConfig</span>(<span class="params">UnrealAppConfig AppConfig, UnrealSessionRole ConfigRole, IEnumerable&lt;UnrealSessionRole&gt; OtherRoles</span>)</span></span><br></pre></td></tr></table></figure>

<p>这个函数的作用就是组装测试的配置，其中 UnrealAppConfig 就是实例启动的相关参数</p>
<p>在 ApplyToConfig 函数中有这几行代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Nullrhi)</span><br><span class="line">&#123;</span><br><span class="line">   AppConfig.CommandLine += <span class="string">&quot; -nullrhi&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序读取了 Nullrhi 这个成员变量，并判断如果为 True 则在 AppConfig 的命令行参数，也就是实例启动的命令行参数中加入 “ -nullrhi” ，从而让客户端不进行渲染</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Use a nullrhi for tests</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">[<span class="meta">AutoParam(false)</span>]</span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">bool</span> Nullrhi &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>Nullrhi 成员使用了注解 [AutoParam(false)]</p>
<p>这个注解的作用是直接从 RunUnreal 的命令行获取参数进行初始化，这个命令行传入有两种写法</p>
<p>我们下面来尝试用这两种写法来使用 nullrhi 参数</p>
<p>修改我们的 RunGauntlet.bat</p>
<p><strong>方法一</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> ProjectPath=项目目录</span><br><span class="line"><span class="built_in">set</span> StagingDir=%ProjectPath%\Saved\StagedBuilds\</span><br><span class="line"><span class="built_in">set</span> EnginePath=引擎目录</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;%EnginePath%\Engine\Build\BatchFiles\RunUAT&quot;</span> RunUnreal -project=%ProjectPath%\GauntletTutorial.uproject ^</span><br><span class="line">-build=%StagingDir% -platform=Win64 -configuration=development ^</span><br><span class="line">-<span class="built_in">test</span>=GauntletTutorial.Automation.GauntletTutorialTest ^</span><br><span class="line">-nullrhi ^</span><br><span class="line">-scriptdir=%ProjectPath%</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p>这里面，我们直接把 nullrhi 当做 RunUnreal 的命令行参数传入</p>
<p><strong>方法二</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> ProjectPath=项目目录</span><br><span class="line"><span class="built_in">set</span> StagingDir=%ProjectPath%\Saved\StagedBuilds\</span><br><span class="line"><span class="built_in">set</span> EnginePath=引擎目录</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;%EnginePath%\Engine\Build\BatchFiles\RunUAT&quot;</span> RunUnreal -project=%ProjectPath%\GauntletTutorial.uproject ^</span><br><span class="line">-build=%StagingDir% -platform=Win64 -configuration=development ^</span><br><span class="line">-<span class="built_in">test</span>=GauntletTutorial.Automation.GauntletTutorialTest(nullrhi) ^</span><br><span class="line">-scriptdir=%ProjectPath%</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p>这里面，我们可以在 test 参数中的的 Gauntlet  测试类型后打一个括号，传入我们的 nullrhi 参数</p>
<p>不管是哪种方式，修改后运行批处理，可以发现客户端没有渲染了，可知是 nullrhi 已经传入了游戏中，其完整流程为</p>
<ol>
<li>通过命令行，参数被 AutoParam 传给了测试的配置类中的成员变量</li>
<li>在配置类的 ApplyToConfig 函数中，通过判断成员变量的值，并在 AppConfig 的 Commandline 中加入到游戏命令行</li>
</ol>
<p>ApplyToConfig 也不光是可以修改命令行，其他用法也可以根据官方代码学习</p>
<h3 id="尝试传入-ErrorTest-所需参数"><a href="#尝试传入-ErrorTest-所需参数" class="headerlink" title="尝试传入 ErrorTest 所需参数"></a>尝试传入 ErrorTest 所需参数</h3><p>我们使用的 Controller 中需要传入命令行参数 errortest.delay 和 errotest.type</p>
<p>于是乎，我们按照上面 nullrhi 的做法，先写一个新的配置类型，继承 UnrealTestConfiguration</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Gauntlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GauntletTutorial.Automation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GauntletTutorialConfig</span> : <span class="title">UnrealTestConfiguration</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">AutoParam(5)</span>] </span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">float</span> ErrorDelay &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  </span><br><span class="line">        [<span class="meta">AutoParam</span>] </span><br><span class="line">        <span class="keyword">private</span> String ErrorType &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ApplyToConfig</span>(<span class="params">UnrealAppConfig AppConfig, UnrealSessionRole ConfigRole,</span></span></span><br><span class="line"><span class="params"><span class="function">            IEnumerable&lt;UnrealSessionRole&gt; OtherRoles</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.ApplyToConfig(AppConfig,ConfigRole,OtherRoles);</span><br><span class="line">            <span class="keyword">if</span> (ErrorDelay &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                AppConfig.CommandLine += <span class="string">&quot; -errortest.delay=&quot;</span> + ErrorDelay;</span><br><span class="line">                AppConfig.CommandLine += <span class="string">&quot; -errortest.type=&quot;</span> + ErrorType;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改我们的 GauntletTutorialTest 的泛型参数为刚创建的新配置类型</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GauntletTutorialTest</span> : <span class="title">UnrealTestNode</span>&lt;<span class="title">GauntletTutorialConfig</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GauntletTutorialTest</span>(<span class="params">UnrealTestContext inContext</span>) : <span class="title">base</span>(<span class="params">inContext</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> GauntletTutorialConfig <span class="title">GetConfiguration</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>

<p>然后修改 RunGauntlet.bat 加入参数 ErrorDelay 和 ErrorType</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> ProjectPath=项目目录</span><br><span class="line"><span class="built_in">set</span> StagingDir=%ProjectPath%\Saved\StagedBuilds\</span><br><span class="line"><span class="built_in">set</span> EnginePath=引擎目录</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;%EnginePath%\Engine\Build\BatchFiles\RunUAT&quot;</span> RunUnreal -project=%ProjectPath%\GauntletTutorial.uproject ^</span><br><span class="line">-build=%StagingDir% -platform=Win64 -configuration=development ^</span><br><span class="line">-<span class="built_in">test</span>=GauntletTutorial.Automation.GauntletTutorialTest(ErrorDelay=20,ErrorType=ensure) ^</span><br><span class="line">-scriptdir=%ProjectPath%</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p>重新启动 RunGauntlet.bat ，发现 20 秒后，提示 ensure ，返回测试失败，我们的参数成功传入到游戏中</p>
<p>至此，我们的整个 Gauntlet 基本流程就算完成了</p>
<h2 id="实战：实现一个基本的测试需求"><a href="#实战：实现一个基本的测试需求" class="headerlink" title="实战：实现一个基本的测试需求"></a>实战：实现一个基本的测试需求</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>我们现在需要测试在 N 个客户端开启后登入一个服务器，确定所有客户端正确登入服务器则测试成功</p>
<h3 id="创建测试配置类型"><a href="#创建测试配置类型" class="headerlink" title="创建测试配置类型"></a>创建测试配置类型</h3><p>创建新的测试配置类型，其中指定一个参数 ClientCount，通过 RunUnreal 命令行传入，用于启动 N 个 Client 实例</p>
<p>然后用 AppConfig 通过命令行参数 -ClientCountToCheck 传入游戏中</p>
<p>可以看到我们这里使用的基类 Config 为 EpicGameTestConfig</p>
<p>使用这个的原因是里面包含了让客户端自动连接服务器的逻辑</p>
<p>LoginTestConfig.cs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Gauntlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GauntletTutorial.Automation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoginTestConfig</span> : <span class="title">EpicGameTestConfig</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">AutoParam(1)</span>] </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> ClientCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ApplyToConfig</span>(<span class="params">UnrealAppConfig AppConfig, UnrealSessionRole ConfigRole, IEnumerable&lt;UnrealSessionRole&gt; OtherRoles</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.ApplyToConfig(AppConfig, ConfigRole, OtherRoles);</span><br><span class="line">            AppConfig.CommandLine += <span class="string">&quot; -ClientCountToCheck=&quot;</span> + ClientCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建测试类型"><a href="#创建测试类型" class="headerlink" title="创建测试类型"></a>创建测试类型</h3><p>在测试中，我们直接把配置中的 ClientCount 取出来，创建相应数量的客户端</p>
<p>然后服务器设置 TestController 为 GauntletTestLoginController，客户端不需要 Controller 所以不设置</p>
<p>设置 NoMCP 为 true，这样可以跳过 Gauntlet 内部客户端登录服务器的账号验证等步骤</p>
<p>如 60 秒还没测试成功，则判断为失败</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Gauntlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GauntletTutorial.Automation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoginTest</span> : <span class="title">UnrealTestNode</span>&lt;<span class="title">LoginTestConfig</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LoginTest</span>(<span class="params">UnrealTestContext inContext</span>) : <span class="title">base</span>(<span class="params">inContext</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> LoginTestConfig <span class="title">GetConfiguration</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            LoginTestConfig config = <span class="keyword">base</span>.GetConfiguration();</span><br><span class="line">            UnrealTestRole server = config.RequireRole(UnrealTargetRole.Server);</span><br><span class="line">            server.Controllers.Add(<span class="string">&quot;GauntletTestLoginController&quot;</span>);</span><br><span class="line">            <span class="comment">// 直接启动配置数量的客户端</span></span><br><span class="line">            config.RequireRoles(UnrealTargetRole.Client, config.ClientCount);</span><br><span class="line">            <span class="comment">// 60 秒后超时，判定为测试失败</span></span><br><span class="line">            config.MaxDuration = <span class="number">60</span>;</span><br><span class="line">            config.MaxDurationReachedResult = EMaxDurationReachedResult.Failure;</span><br><span class="line">            config.NoMCP = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> config;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-GauntletController"><a href="#创建-GauntletController" class="headerlink" title="创建 GauntletController"></a>创建 GauntletController</h3><p>首先，在游戏项目中的 GauntletTutorial.build.cs 中</p>
<p>PublicDependencyModuleNames 中加入 “Gauntlet”</p>
<p>然后创建新 C++ 类型 UGauntletTestLoginController</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GauntletTestController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GauntletTestLoginController.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GAUNTLETTUTORIAL_API</span> <span class="title">UGauntletTestLoginController</span> :</span> <span class="keyword">public</span> UGauntletTestController</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnInit</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnTick</span><span class="params">(<span class="keyword">float</span> TimeDelta)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">OnClientLogin</span><span class="params">(AGameModeBase* GameMode, APlayerController* NewPlayer)</span></span>;</span><br><span class="line"></span><br><span class="line">   int32 CurrentClientCount;</span><br><span class="line">   int32 ClientCountShouldLogin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GauntletTestLoginController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GameFramework/GameModeBase.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UGauntletTestLoginController::OnInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">OnInit</span>();</span><br><span class="line">   CurrentClientCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   FParse::<span class="built_in">Value</span>(FCommandLine::<span class="built_in">Get</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;ClientCountToCheck=&quot;</span>), ClientCountShouldLogin);</span><br><span class="line">   FGameModeEvents::GameModePostLoginEvent.<span class="built_in">AddUObject</span>(<span class="keyword">this</span>,&amp;UGauntletTestLoginController::OnClientLogin);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UGauntletTestLoginController::OnTick</span><span class="params">(<span class="keyword">float</span> TimeDelta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">OnTick</span>(TimeDelta);</span><br><span class="line">   <span class="comment">// 全部都登入啦</span></span><br><span class="line"><span class="keyword">if</span> (CurrentClientCount == ClientCountShouldLogin)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">EndTest</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UGauntletTestLoginController::OnClientLogin</span><span class="params">(AGameModeBase* GameMode, APlayerController* NewPlayer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   CurrentClientCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注册全局登入事件，然后判断登录的客户端数量是否能达到配置的人数</p>
<p>如果进入的数量和配置的数量相等了，则结束测试，返回代表成功的结果0</p>
<h3 id="编写测试批处理"><a href="#编写测试批处理" class="headerlink" title="编写测试批处理"></a>编写测试批处理</h3><p>在 [ProjectDir]\Scripts 目录下创建 RunLoginTest.bat ，test 传入 LogintTest,  并传入参数 ClientCount 5</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> ProjectPath=项目目录</span><br><span class="line"><span class="built_in">set</span> StagingDir=%ProjectPath%\Saved\StagedBuilds\</span><br><span class="line"><span class="built_in">set</span> EnginePath=引擎目录</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;%EnginePath%\Engine\Build\BatchFiles\RunUAT&quot;</span> RunUnreal -project=%ProjectPath%\GauntletTutorial.uproject ^</span><br><span class="line">-build=%StagingDir% -platform=Win64 -configuration=development ^</span><br><span class="line">-<span class="built_in">test</span>=GauntletTutorial.Automation.LoginTest(ClientCount=5) ^</span><br><span class="line">-scriptdir=%ProjectPath%</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<h3 id="打包，运行测试"><a href="#打包，运行测试" class="headerlink" title="打包，运行测试"></a>打包，运行测试</h3><p>运行 Pack.bat 打包</p>
<p>然后运行 RunLoginTest.bat 开启测试</p>
<p>可以看到当 6 个 device 都启动后，测试显示成功</p>
<p>然后查看 Server 的日志</p>
<p>日志在 [Engin]\GauntletTemp\DeviceCache\Win64[LocalDevice”N”]\UserDir\Saved\Logs 中</p>
<p>这里的服务器大概率应该是 LocalDevice0，其他的客户端应该是 LocalDevice1 ~ 5</p>
<p>日志中显示 5 个客户端登录成功，我们的需求完成</p>
<h1 id="调试-RunUnreal-和-游戏实例"><a href="#调试-RunUnreal-和-游戏实例" class="headerlink" title="调试 RunUnreal 和 游戏实例"></a>调试 RunUnreal 和 游戏实例</h1><p>我们在学习和测试中，经常会有需要调试 Gauntlet Automation 或者在特定实例调试的情况</p>
<h3 id="调试-RunUnreal"><a href="#调试-RunUnreal" class="headerlink" title="调试 RunUnreal"></a>调试 RunUnreal</h3><p>这时我们只需在 RunUAT 命令行参数中加入 -waitfordebugger</p>
<p>再运行 Gauntlet 测试，就会在启动时等待调试器接入</p>
<p>然后我们在 Automation 项目代码中打好断点，然后在 Rider 中选择 Run -&gt; AttachToProcess</p>
<p>然后过滤输入 Automation ，在进程中选中 dotnet(AutomationTool.dll) 开始调试即可</p>
<img src="/2023/02/10/UE5%EF%BC%9A%E7%AE%80%E8%BF%B0Gauntlet%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/%E8%B0%83%E8%AF%95Automation.png" class title="调试Automation">

<h3 id="调试特定游戏实例"><a href="#调试特定游戏实例" class="headerlink" title="调试特定游戏实例"></a>调试特定游戏实例</h3><p>我们知道游戏中传入参数 -waitfordebugger 就可以等待调试器接入</p>
<p>所以我们只需按照之前传参到特定实例的方法传入参数</p>
<p>然后在游戏项目中打好断点，attach 到游戏进程即可</p>
<h1 id="相关学习和参考"><a href="#相关学习和参考" class="headerlink" title="相关学习和参考"></a>相关学习和参考</h1><p>现在我们已经了解了 Gauntlet 的基本使用</p>
<p>如果需要了解和学习更多的用法，可以</p>
<ul>
<li>查看 Gauntlet Automation 项目中相关源代码，学习借鉴其中的用法</li>
<li>查看相关测官网文档</li>
<li>查看一些使用案例</li>
</ul>
<h2 id="可供参考的项目"><a href="#可供参考的项目" class="headerlink" title="可供参考的项目"></a>可供参考的项目</h2><h3 id="DaedalicTestAutomation-插件"><a href="#DaedalicTestAutomation-插件" class="headerlink" title="DaedalicTestAutomation 插件"></a>DaedalicTestAutomation 插件</h3><p><a target="_blank" rel="noopener" href="https://github.com/DaedalicEntertainment/ue4-test-automation">Github 地址</a></p>
<p>这个插件写了一套测试框架，然后也集成了使用 Gauntlet 来启动测试的方式，很有参考价值</p>
<h3 id="ShooterGame-示例项目"><a href="#ShooterGame-示例项目" class="headerlink" title="ShooterGame 示例项目"></a>ShooterGame 示例项目</h3><p>官方示例项目中，包含了一些 Gauntlet Automation 和 Gauntlet Test Controller 的使用实例</p>
<h3 id="本文项目的-Github-仓库"><a href="#本文项目的-Github-仓库" class="headerlink" title="本文项目的 Github 仓库"></a>本文项目的 Github 仓库</h3><p><a target="_blank" rel="noopener" href="https://github.com/Mapz/GauntletTutorial">Github 仓库地址</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mapz.github.io/2023/02/10/%E8%A7%A3%E5%86%B3Hexo%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/link-300x300.gif">
      <meta itemprop="name" content="Mapz">
      <meta itemprop="description" content="FIND THE CHILD">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mapz's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/10/%E8%A7%A3%E5%86%B3Hexo%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">解决Hexo无法显示图片的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-10 16:41:36 / 修改时间：16:43:23" itemprop="dateCreated datePublished" datetime="2023-02-10T16:41:36+08:00">2023-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7006594302604214280">解决hexo引用本地图片无法显示的问题</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mapz.github.io/2023/02/02/UE5%EF%BC%9A%E7%99%BB%E5%BD%95%E6%8F%A1%E6%89%8B%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E7%AE%80%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/link-300x300.gif">
      <meta itemprop="name" content="Mapz">
      <meta itemprop="description" content="FIND THE CHILD">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mapz's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/02/UE5%EF%BC%9A%E7%99%BB%E5%BD%95%E6%8F%A1%E6%89%8B%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E7%AE%80%E6%9E%90/" class="post-title-link" itemprop="url">UE5：登录握手控制消息简析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-02 16:54:16 / 修改时间：18:26:46" itemprop="dateCreated datePublished" datetime="2023-02-02T16:54:16+08:00">2023-02-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="常见控制消息与参数列表"><a href="#常见控制消息与参数列表" class="headerlink" title="常见控制消息与参数列表"></a>常见控制消息与参数列表</h2><h3 id="Hello"><a href="#Hello" class="headerlink" title="Hello"></a>Hello</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CONTROL_CHANNEL_MESSAGE(Hello, 0, uint8, uint32, FString); // initial client connection message</span><br></pre></td></tr></table></figure>

<p>客户端发起登录初始化</p>
<p>参数：大小端    本地客户端的网络版本    网络加密Token</p>
<h3 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CONTROL_CHANNEL_MESSAGE(Upgrade, 2, uint32); // server tells client their version is incompatible</span><br></pre></td></tr></table></figure>

<p>告诉客户端版本不匹配</p>
<p>参数：服务器版本号</p>
<h3 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CONTROL_CHANNEL_MESSAGE(Challenge, 3, FString); // server sends client challenge string to verify integrity</span><br></pre></td></tr></table></figure>

<p>服务器让客户端开始登录</p>
<p>参数：当前时间</p>
<h3 id="Login"><a href="#Login" class="headerlink" title="Login"></a>Login</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CONTROL_CHANNEL_MESSAGE(Login, 5, FString, FString, FUniqueNetIdRepl, FString); // client requests to be admitted to the game</span><br></pre></td></tr></table></figure>

<p>客户端发起登录</p>
<p>参数：默认客户端反馈”0”     客户端登录Url字符串    PlayerID    平台名称</p>
<h3 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a>Welcome</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CONTROL_CHANNEL_MESSAGE(Welcome, 1, FString, FString, FString); // server tells client they&#x27;re ok&#x27;ed to load the server&#x27;s level</span><br></pre></td></tr></table></figure>

<p>服务器欢迎客户端登陆</p>
<p>参数：地图名称    GameMode名称    重定向URL</p>
<h3 id="NetSpeed"><a href="#NetSpeed" class="headerlink" title="NetSpeed"></a>NetSpeed</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CONTROL_CHANNEL_MESSAGE(Netspeed, 4, int32); // client sends requested transfer rate</span><br></pre></td></tr></table></figure>

<p>客户端请求设置网速</p>
<p>参数：网速</p>
<h3 id="Failure"><a href="#Failure" class="headerlink" title="Failure"></a>Failure</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CONTROL_CHANNEL_MESSAGE(Failure, 6, FString); // indicates connection failure</span><br></pre></td></tr></table></figure>

<p>失败，各种意义上的，一般会断开连接</p>
<p>参数：失败原因</p>
<h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CONTROL_CHANNEL_MESSAGE(Join, 9); // final join request (spawns PlayerController)</span><br></pre></td></tr></table></figure>

<p>客户端正式加入游戏中</p>
<p>参数：无</p>
<h3 id="JoinSplit"><a href="#JoinSplit" class="headerlink" title="JoinSplit"></a>JoinSplit</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CONTROL_CHANNEL_MESSAGE(JoinSplit, 10, FString, FUniqueNetIdRepl); // child player (splitscreen) join request</span><br></pre></td></tr></table></figure>

<p>向服务器发送分屏玩家加入请求</p>
<p>参数：URL    玩家UniqueNetId</p>
<h3 id="EncryptionAck"><a href="#EncryptionAck" class="headerlink" title="EncryptionAck"></a>EncryptionAck</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CONTROL_CHANNEL_MESSAGE(EncryptionAck, 21);</span><br></pre></td></tr></table></figure>

<p>向客户端发送收到流量加密请求</p>
<p>参数：无</p>
<h3 id="GameSpecific"><a href="#GameSpecific" class="headerlink" title="GameSpecific"></a>GameSpecific</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_CONTROL_CHANNEL_MESSAGE(GameSpecific, 20, uint8, FString); // custom game-specific message routed to UGameInstance for processing</span><br></pre></td></tr></table></figure>

<p>自由定义的命令，会在 UGameInstance::HandleGameNetControlMessage 中处理</p>
<p>参数：命令的Byte    命令的字符串</p>
<h2 id="登录流程控制消息顺序"><a href="#登录流程控制消息顺序" class="headerlink" title="登录流程控制消息顺序"></a>登录流程控制消息顺序</h2><ul>
<li><p>客户端</p>
<ul>
<li>发送 Hello 到服务器</li>
</ul>
</li>
<li><p>服务器收到 Hello</p>
<ul>
<li>判断两边的网络版本是否匹配，不匹配则发送 Upgrade 到客户端</li>
<li>版本匹配则查看是否有加密 Token<ul>
<li>如果没有，则发送 Challenge 到客户端（5.0 以及以前）</li>
<li>如果没有，则判断是否强制开启加密（5.1 以及以后）<ul>
<li>如果强制开启加密，则发送 Failure 到客户端，原因是缺少 Encrypt Token</li>
<li>如果没有开启，则发送 Challenge 到客户端</li>
</ul>
</li>
<li></li>
<li>如果有，则调用 UGameInstance::ReceivedNetworkEncryptionToken 解析 Token<ul>
<li>如果解析成功<ul>
<li>开启加密，向客户端发送 EncryptionAck 到客户端</li>
<li>发送 Challenge 到客户端</li>
</ul>
</li>
<li>解析失败<ul>
<li>发送 Failure 到客户端</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>客户端收到 EncryptionAck</p>
<ul>
<li>客户端执行 UGameInstance::ReceivedNetworkEncryptionAck ，客户端开启加密</li>
</ul>
</li>
<li><p>客户端收到 Challenge</p>
<ul>
<li>组装一些参数（玩家昵称 ，还有 GetGameLoginOptions）到 URL，并和平台名和 PlayerID 等一起发送消息 Login 到服务器</li>
</ul>
</li>
<li><p>服务器收到 Login</p>
<ul>
<li>调用 GameMode-&gt;PreLogin，使用 Login 消息传入的 PlayerID<ul>
<li>PreLogin 没有 Error Message<ul>
<li>调用 AuthorityGameMode-&gt;GameWelcomePlayer</li>
<li>向客户端发送 Welcome</li>
</ul>
</li>
<li>PreLogin 有 Error Message，则向客户端发送 Failure</li>
</ul>
</li>
</ul>
</li>
<li><p>客户端收到 Welcome</p>
<ul>
<li>发送 NetSpeed 消息到服务器</li>
</ul>
</li>
<li><p>服务器收到 NetSpeed</p>
<ul>
<li>设置 Connection 的 NetSpeed</li>
</ul>
</li>
<li><p>客户端收到 Failure</p>
<ul>
<li>关闭网络连接</li>
</ul>
</li>
<li><p>客户端加载地图完成</p>
<ul>
<li>发送 Join 到服务器</li>
</ul>
</li>
<li><p>服务器收到 Join</p>
<ul>
<li>创建 PlayerController<ul>
<li>创建失败：发送 Failure</li>
<li>创建成功：标记玩家状态为 Join，开始 ClientTravel</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mapz.github.io/2023/02/01/UE5%EF%BC%9A%E5%B0%8F%E7%82%B9%E7%82%B9%E9%9A%8F%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/link-300x300.gif">
      <meta itemprop="name" content="Mapz">
      <meta itemprop="description" content="FIND THE CHILD">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mapz's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/UE5%EF%BC%9A%E5%B0%8F%E7%82%B9%E7%82%B9%E9%9A%8F%E8%AE%B0/" class="post-title-link" itemprop="url">UE5：小点点随记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-01 12:11:09" itemprop="dateCreated datePublished" datetime="2023-02-01T12:11:09+08:00">2023-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-10 16:41:09" itemprop="dateModified" datetime="2023-02-10T16:41:09+08:00">2023-02-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="这篇文章主要记录一些平时想到和看到的-UE-Tips"><a href="#这篇文章主要记录一些平时想到和看到的-UE-Tips" class="headerlink" title="这篇文章主要记录一些平时想到和看到的 UE Tips"></a>这篇文章主要记录一些平时想到和看到的 UE Tips</h1><h3 id="RPC-实现调用-XXX-Implementation-和-XXX-Validate-的方式"><a href="#RPC-实现调用-XXX-Implementation-和-XXX-Validate-的方式" class="headerlink" title="RPC 实现调用 XXX_Implementation 和 XXX_Validate 的方式"></a>RPC 实现调用 XXX_Implementation 和 XXX_Validate 的方式</h3><p>其实是 UHT 里面自动生成的 execXXX 函数中调用 Validate 和 Implementation 的逻辑，所以 XXX_Implementation 不是 UFUNCTION 也很正常，因为真正的 UFUNCTION 是根据 RPC 宏自动生成的 execXXX，所以如果要魔改逻辑，只能改 UHT 源码了</p>
<h3 id="CallInEditor"><a href="#CallInEditor" class="headerlink" title="CallInEditor"></a>CallInEditor</h3><p>一个 UFUNCTION 宏中，如果加上宏参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CallInEditor</span><br></pre></td></tr></table></figure>

<p>那么会在编辑器的 Property 面板中生成一个同名按钮，点击后可以执行这个函数</p>
<p>同样的，如果是蓝图类，在 CustomEvent 节点的属性面板中也有一个 CallInEditor 的勾选框</p>
<p>效果是一样的</p>
<p>但是有一个限制，就是函数不能带参数，否则不会生成 Property 面板按钮</p>
<h3 id="使用-ini-重新设置控制台变量-CVar-的值"><a href="#使用-ini-重新设置控制台变量-CVar-的值" class="headerlink" title="使用 ini 重新设置控制台变量 CVar 的值"></a>使用 ini 重新设置控制台变量 CVar 的值</h3><p>在 DefaultEngine.ini 中，添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SystemSettings]</span><br><span class="line">xxx.yyy = zzz</span><br></pre></td></tr></table></figure>

<p>其中 xxx.yyy 是控制台变量的名称，zzz 为覆盖默认值</p>
<h3 id="Map-Check"><a href="#Map-Check" class="headerlink" title="Map Check"></a>Map Check</h3><p>Map Check 可以帮助你更好的检查地图中的 Actor 是否存在错误或者不适当的配置</p>
<p>执行主菜单的-&gt;Build-&gt;MapCheck 即可执行检查当前地图（UE5下)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Function that gets called from within Map_Check to allow this actor to check itself</span><br><span class="line"> * for any potential errors and register them with map check dialog.</span><br><span class="line"> */</span><br><span class="line">virtual void CheckForErrors();</span><br></pre></td></tr></table></figure>

<p>在你自己的 Actor 派生类重写 CheckForErrors ，在其中添加检查逻辑即可</p>
<p>检查逻辑可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMessageLog(&quot;MapCheck&quot;)</span><br></pre></td></tr></table></figure>

<p>来生成编辑器 Console 提示，其还可以 Add 各种 Token 来进行帮助跳转</p>
<img src="/2023/02/01/UE5%EF%BC%9A%E5%B0%8F%E7%82%B9%E7%82%B9%E9%9A%8F%E8%AE%B0/Tokens.png" class title="Token列表">

<p>其中 ActorToken 点击可跳转 Actor，ActionToken 点击可以执行一个自定义的命令，AssetNameToken 点击可跳转相关资源，等待</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mapz.github.io/2023/01/19/UE5-1%E7%9C%8B%E6%BA%90%E7%A0%81%EF%BC%9A%E6%96%B0%E5%A2%9E%E9%83%A8%E5%88%86%EF%BC%8C%E8%BE%B9%E7%9C%8B%E8%BE%B9%E6%9B%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/link-300x300.gif">
      <meta itemprop="name" content="Mapz">
      <meta itemprop="description" content="FIND THE CHILD">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mapz's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/19/UE5-1%E7%9C%8B%E6%BA%90%E7%A0%81%EF%BC%9A%E6%96%B0%E5%A2%9E%E9%83%A8%E5%88%86%EF%BC%8C%E8%BE%B9%E7%9C%8B%E8%BE%B9%E6%9B%B4/" class="post-title-link" itemprop="url">UE5.1看源码：新增部分，边看边更</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-19 17:25:08" itemprop="dateCreated datePublished" datetime="2023-01-19T17:25:08+08:00">2023-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-31 19:48:23" itemprop="dateModified" datetime="2023-01-31T19:48:23+08:00">2023-01-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h2><ul>
<li><p>控制命令新增 NMT_Ping，衍生出 NetPing.h 相关内容</p>
</li>
<li><p>Iris 同步系统（实验性）</p>
</li>
<li><p>SubObject 新同步特性</p>
<ul>
<li>ActorComponent 新增函数 ReadyForReplication</li>
<li>FReplicatedComponentsInfo 类型</li>
<li>现在 Actor 会自己管理一个 ReplicatedComponent 的列表</li>
</ul>
</li>
<li><p>流量加密</p>
<ul>
<li>NetDriver 中增加了两个可以覆盖的函数，DoesSupportEncryption IsEncryptionRequired，需要强制开启加密就不需要搞魔法了</li>
</ul>
</li>
<li><p>Replication Graph</p>
<ul>
<li>性能分析中增加了 RedundantRepCPUTimeAccumulated ，无用 CPU 耗时，详见 FReplicationGraphCSVTracker</li>
<li>为每个节点增加了 virtual void Serialize(FArchive&amp; Ar); 序列化函数，用于数据内存大小的 Tracking</li>
<li>FStreamingLevelActorListCollection 符号现在导出了，可在外部使用</li>
<li>针对超出距离的 Actor 增加了一个 OutOfRangeList，和 DestructDistance 区分，没有到销毁距离，但是到了 OutOfRanged 的，先移入一个列表中</li>
</ul>
</li>
</ul>
<h2 id="系统部分"><a href="#系统部分" class="headerlink" title="系统部分"></a>系统部分</h2><ul>
<li>UClass 新增 TryFindTypeSlow 函数</li>
<li>TCppStructOps 把 Traits 的判断放在了编译期</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mapz.github.io/2023/01/11/UE5%EF%BC%9A%E5%90%90%E6%A7%BDUInterface%E4%B8%AD%E4%BD%BF%E7%94%A8BlueprintNativeEvent%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/link-300x300.gif">
      <meta itemprop="name" content="Mapz">
      <meta itemprop="description" content="FIND THE CHILD">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mapz's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/11/UE5%EF%BC%9A%E5%90%90%E6%A7%BDUInterface%E4%B8%AD%E4%BD%BF%E7%94%A8BlueprintNativeEvent%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">UE5：吐槽UInterface中使用BlueprintNativeEvent的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-01-11 20:45:15 / 修改时间：20:51:58" itemprop="dateCreated datePublished" datetime="2023-01-11T20:45:15+08:00">2023-01-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本身我们在 uclass 中，去创建一个 BlueprintNativeEvent 的函数的时候</p>
<p>可以有一个默认 c++ 实现，然后蓝图中，可以选择性的使用蓝图函数 override c++ 的实现</p>
<p>可是在 uinterface 中使用 BlueprintNativeEvent 的话</p>
<p>如果在蓝图中手动 implement 接口的话，会把函数的 override 蓝图空函数自动创建出来，并且呢，删都删不掉呢</p>
<p>默认的 c++ 实现就变得访问不到啦</p>
<p>个人倾向于是个 Bug，并且是改不动这种</p>
<hr>
<p>顺便，一个继承了 A 接口的 B 类型 UObject</p>
<p>它的 CDO 如果 Cast &lt;A&gt;，会得到一个 nullptr</p>
<p>很反直觉</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mapz.github.io/2023/01/11/UE5%EF%BC%9A%E6%8A%8AGameMode%E5%8F%AA%E7%BC%96%E8%AF%91%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/link-300x300.gif">
      <meta itemprop="name" content="Mapz">
      <meta itemprop="description" content="FIND THE CHILD">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mapz's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/11/UE5%EF%BC%9A%E6%8A%8AGameMode%E5%8F%AA%E7%BC%96%E8%AF%91%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">UE5：把GameMode只编译到服务器上导致的问题及解决方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-01-11 20:37:45 / 修改时间：20:44:12" itemprop="dateCreated datePublished" datetime="2023-01-11T20:37:45+08:00">2023-01-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近尝试服务器客户端代码分离，于是只在服务器上存在的 GameMode 类型，理所当然的被分到服务器专属模块中</p>
<p>但是打出包后，客户端连接上服务器后，任然会去加载 GameMode 类型，但由于找不到，会导致报错或崩溃</p>
<p>于是顺着 Debug 了下服务器发包</p>
<p>发现 AGameStateBase 中，有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPROPERTY(Transient, BlueprintReadOnly, Category=GameState, ReplicatedUsing=OnRep_GameModeClass)</span><br><span class="line">TSubclassOf&lt;AGameModeBase&gt;  GameModeClass;</span><br></pre></td></tr></table></figure>

<p>作为一个变量同步到客户端</p>
<p>查找了下，这个变量在客户端上并没有什么卵用</p>
<p>不理解为啥 Epic 会把这个东西设置为同步</p>
<p>于是在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetLifetimeReplicatedProps</span><br></pre></td></tr></table></figure>

<p>中果断使用宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DISABLE_REPLICATED_PROPERTY</span><br></pre></td></tr></table></figure>

<p>关闭 GameModeClass 的同步</p>
<p>顺利解决问题</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://mapz.github.io/2022/12/28/UE5%EF%BC%9A%E4%BF%AE%E6%94%B9%E6%89%93%E5%87%BA%E5%8C%85%E7%9A%84exe%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%8D%E7%A7%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/link-300x300.gif">
      <meta itemprop="name" content="Mapz">
      <meta itemprop="description" content="FIND THE CHILD">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mapz's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/28/UE5%EF%BC%9A%E4%BF%AE%E6%94%B9%E6%89%93%E5%87%BA%E5%8C%85%E7%9A%84exe%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%8D%E7%A7%B0/" class="post-title-link" itemprop="url">UE5：修改打出包的exe文件的名称</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-28 10:24:00" itemprop="dateCreated datePublished" datetime="2022-12-28T10:24:00+08:00">2022-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-30 16:45:07" itemprop="dateModified" datetime="2022-12-30T16:45:07+08:00">2022-12-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近需要修改打出的 exe 的名称</p>
<p>在网上找了半天都只是说需要修改 uproject 的名称</p>
<p>有没有办法在不修改 uproject 的名称的前提下，修改打出的包名呢</p>
<p>答案是肯定的</p>
<ol>
<li>修改 xxx.Target.cs 的 xxx 部分</li>
<li>修改其中的类名和 xxx 一致</li>
<li>打出来的 exe 名称就是 xxx.exe</li>
</ol>
<h2 id="导致的问题"><a href="#导致的问题" class="headerlink" title="导致的问题"></a>导致的问题</h2><p>Gauntlet 测试的时候，如果按 Path 传入打好的可执行文件，命名和 uproject 不同可能导致无法找到 Role 相应的 exe</p>
<p>例如 项目名称为 AAA 的时候，寻找 Role 为 Server 的包，会寻找名称为 AAAServer.exe 的可执行文件</p>
<p>如果随意修改打出的 exe 名称为 BBB ，则会找不到 Role 为 Server 的包</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>修改打出的 exe 名称，还是需要和 uproject 名称结合使用，因为 UAT 里面一些功能项目名和 exe 有部分耦合（万恶的 Gauntlet）</p>
<p>例如 AAA.uproject 最好把 Server Target 命名为 AAAServer</p>
<p>Client Target 命名为 AAAClient</p>
<p>Game Target 命名为 AAA 或 AAAGame</p>
<p>Editor Target 命名为 AAAEditor</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mapz"
      src="/images/link-300x300.gif">
  <p class="site-author-name" itemprop="name">Mapz</p>
  <div class="site-description" itemprop="description">FIND THE CHILD</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Mapz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Mapz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

</body>
</html>
